{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to ROSflight\n\u00b6\n\n\nROSflight is an autopilot system that is designed from the ground up for integration with \nROS\n. It's purpose is to accomplish two main tasks:\n\n\n\n\nStream high-rate sensor data from the embedded flight controller to ROS\n\n\nProvide a simple API for sending control setpoints to the embedded flight controller\n\n\n\n\nA ROSflight setup consists of two main components:\n\n\n\n\nThe embedded flight controller:\n Typically an openpilot Revo or one of its variants, running the ROSflight \nfirmware\n\n\nThe onboard computer:\n Any computer that runs ROS, located on the vehicle with a physical serial connection to the embedded flight controller\n\n\n\n\nWhy ROSflight?\n\u00b6\n\n\nThere are a lot of excellent autopilots out there, with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Specifically, we needed an autopilot that could stream sensor data at high rates, easily accept control setpoints from an onboard computer, and accomplish all of this with a lean, easy to understand code base.\n\n\nThe other options that we tried were limited in bandwidth for streaming sensor data, and the APIs for sending control setpoints were confusing and difficult to implement. Perhaps most importantly, the code was sometimes so complex (feature-rich, but complicated) that it was difficult to figure out what the autopilot was actually doing. In talking to other researchers and industry members, we found that many people shared similar frustrations. So we decided to create the autopilot that we wanted and share it in the hopes that it will be useful to other people as well.\n\n\nOur Vision\n\u00b6\n\n\nPerhaps more important than what we're trying to accomplish with ROSflight is what we're \nnot\n trying to accomplish. This is not intended to be, out-of-the-box, a fully-featured autopilot for high-level tasks such as autonomous GPS waypoint following. There are many good autopilots out there that already do this. Instead, ROSflight is intended to provide the minimal functionality required to keep a multirotor or fixed-wing vehicle in the air, and to serve as a building block for writing new code to perform these higher-level tasks (the \nROSplane\n and \nROScopter\n projects are excellent examples of what can be accomplished by building on top of the ROSflight architecture).\n\n\nTherefore, one of the primary objectives of the ROSflight autopilot is to avoid feature creep and remain \nlean\n. We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-rosflight",
            "text": "ROSflight is an autopilot system that is designed from the ground up for integration with  ROS . It's purpose is to accomplish two main tasks:   Stream high-rate sensor data from the embedded flight controller to ROS  Provide a simple API for sending control setpoints to the embedded flight controller   A ROSflight setup consists of two main components:   The embedded flight controller:  Typically an openpilot Revo or one of its variants, running the ROSflight  firmware  The onboard computer:  Any computer that runs ROS, located on the vehicle with a physical serial connection to the embedded flight controller",
            "title": "Welcome to ROSflight"
        },
        {
            "location": "/#why-rosflight",
            "text": "There are a lot of excellent autopilots out there, with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Specifically, we needed an autopilot that could stream sensor data at high rates, easily accept control setpoints from an onboard computer, and accomplish all of this with a lean, easy to understand code base.  The other options that we tried were limited in bandwidth for streaming sensor data, and the APIs for sending control setpoints were confusing and difficult to implement. Perhaps most importantly, the code was sometimes so complex (feature-rich, but complicated) that it was difficult to figure out what the autopilot was actually doing. In talking to other researchers and industry members, we found that many people shared similar frustrations. So we decided to create the autopilot that we wanted and share it in the hopes that it will be useful to other people as well.",
            "title": "Why ROSflight?"
        },
        {
            "location": "/#our-vision",
            "text": "Perhaps more important than what we're trying to accomplish with ROSflight is what we're  not  trying to accomplish. This is not intended to be, out-of-the-box, a fully-featured autopilot for high-level tasks such as autonomous GPS waypoint following. There are many good autopilots out there that already do this. Instead, ROSflight is intended to provide the minimal functionality required to keep a multirotor or fixed-wing vehicle in the air, and to serve as a building block for writing new code to perform these higher-level tasks (the  ROSplane  and  ROScopter  projects are excellent examples of what can be accomplished by building on top of the ROSflight architecture).  Therefore, one of the primary objectives of the ROSflight autopilot is to avoid feature creep and remain  lean . We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.",
            "title": "Our Vision"
        },
        {
            "location": "/user-guide/getting-started/",
            "text": "Getting Started\n\u00b6\n\n\nReading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages:\n\n\n\n\nSet up your hardware\n (fixed-wing or multirotor platform, autopilot, and onboard computer)\n\n\nFlash your autopilot with the latest ROSflight firmware\n\n\nSet up your RC transmitter\n\n\nSet up ROS on your onboard computer\n\n\nConfigure the autopilot for your setup\n. The configuration checklists below should help guide you through this process.\n\n\nRun through your preflight checks\n\n\nTune the attitude controller gains\n (multirotors only)\n\n\nSet up autonomous flight via offboard control\n (optional)\n\n\n\n\nConfiguration Checklist\n\u00b6\n\n\nThe following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your \nhardware is already set up correctly\n.\n\n\nGeneral setup\n\u00b6\n\n\n\n\nSet the \nFIXED_WING\n parameter (\n1\n if a fixed-wing, \n0\n if a multirotor)\n\n\nSet the \nMIXER\n parameter to the appropriate value described in the \nHardware Setup\n page\n\n\nSet the \nMOTOR_PWM_UPDATE\n parameter (typically \n490\n for SimonK ESCs, \n50\n for standard servos)\n\n\nMake sure your \nRC transmitter is set up correctly\n\n\nSet up your RC switches\n\n\nIf you want to arm/disarm using a switch, set the \nARM_CHANNEL\n parameter to the appropriate channel (0-indexed)\n\n\nIf you want to use a switch to enable RC override, set the \nRC_ATT_OVRD_CHN\n and \nRC_THR_OVRD_CHN\n parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel.\n\n\n\n\n\n\nCalibrate your IMU: start \nrosflight_io\n, then run \nrosservice call /calibrate_imu\n\n\nComplete the multirotor-specific or fixed-wing-specific checklist below\n\n\nSave the parameters (\nrosservice call /param_write\n)\n\n\nYou'll probably want to save a backup of your parameters (call \nrosservice call /param_save_to_file /path/to/file.yml\n)\n\n\nMake sure you run through the \nPreflight Checklist\n before flying\n\n\n\n\n\n\nWarning\n\n\nIMPORTANT: Remove all props from the vehicle when calibrating ESCs!!!\n\n\n\n\n\n\n\n\nCalibrate ESCs\n\n\n\n\nMake sure \nMOTOR_MIN_PWM\n and \nMOTOR_MAX_PWM\n are correct (usually \n1000\n and \n2000\n)\n\n\nSet \nMIXER\n param to \n0\n (ESC calibration mixer)\n\n\nSet \nARM_SPIN_MOTORS\n to \n0\n\n\n\n\nPerform ESC calibration. For standard ESCs:\n\n\n\n\nWith power disconnected from the motors, arm the flight controller\n\n\nSet throttle to maximum\n\n\nConnect power to the motors\n\n\nDrop the throttle to minimum\n\n\n\n\n\n\n\n\nSet the \nMIXER\n parameter back to the appropriate value for your vehicle (see the \nHardware Setup\n page)\n\n\n\n\nSet \nARM_SPIN_MOTORS\n back to \n1\n\n\n\n\n\n\n\n\nYou'll most likely want to set the \nCAL_GYRO_ARM\n param to \n1\n to enable calibrating gyros before arming\n\n\n\n\nSet the \nRC_ATT_MODE\n parameter to set RC control mode (\n0\n for rate mode, \n1\n for angle mode [default])\n\n\nSet torque offsets as described in the \nRC trim calculation\n section of the Improving Performance page\n\n\nTune the controller gains as described in the \nMultirotor gain tuning\n section of the Improving Performance page\n\n\n\n\nFixed-wing-specific setup\n\u00b6\n\n\n\n\nReverse servo directions if necessary using the \nAIL_REV\n, \nELEVATOR_REV\n, and \nRUDDER_REV\n parameters (\n1\n to reverse, \n0\n to keep current direction)\n\n\nYou'll most likely want to set the \nARM_SPIN_MOTORS\n parameter to \n0\n so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching",
            "title": "Getting started"
        },
        {
            "location": "/user-guide/getting-started/#getting-started",
            "text": "Reading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages:   Set up your hardware  (fixed-wing or multirotor platform, autopilot, and onboard computer)  Flash your autopilot with the latest ROSflight firmware  Set up your RC transmitter  Set up ROS on your onboard computer  Configure the autopilot for your setup . The configuration checklists below should help guide you through this process.  Run through your preflight checks  Tune the attitude controller gains  (multirotors only)  Set up autonomous flight via offboard control  (optional)",
            "title": "Getting Started"
        },
        {
            "location": "/user-guide/getting-started/#configuration-checklist",
            "text": "The following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your  hardware is already set up correctly .",
            "title": "Configuration Checklist"
        },
        {
            "location": "/user-guide/getting-started/#general-setup",
            "text": "Set the  FIXED_WING  parameter ( 1  if a fixed-wing,  0  if a multirotor)  Set the  MIXER  parameter to the appropriate value described in the  Hardware Setup  page  Set the  MOTOR_PWM_UPDATE  parameter (typically  490  for SimonK ESCs,  50  for standard servos)  Make sure your  RC transmitter is set up correctly  Set up your RC switches  If you want to arm/disarm using a switch, set the  ARM_CHANNEL  parameter to the appropriate channel (0-indexed)  If you want to use a switch to enable RC override, set the  RC_ATT_OVRD_CHN  and  RC_THR_OVRD_CHN  parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel.    Calibrate your IMU: start  rosflight_io , then run  rosservice call /calibrate_imu  Complete the multirotor-specific or fixed-wing-specific checklist below  Save the parameters ( rosservice call /param_write )  You'll probably want to save a backup of your parameters (call  rosservice call /param_save_to_file /path/to/file.yml )  Make sure you run through the  Preflight Checklist  before flying    Warning  IMPORTANT: Remove all props from the vehicle when calibrating ESCs!!!     Calibrate ESCs   Make sure  MOTOR_MIN_PWM  and  MOTOR_MAX_PWM  are correct (usually  1000  and  2000 )  Set  MIXER  param to  0  (ESC calibration mixer)  Set  ARM_SPIN_MOTORS  to  0   Perform ESC calibration. For standard ESCs:   With power disconnected from the motors, arm the flight controller  Set throttle to maximum  Connect power to the motors  Drop the throttle to minimum     Set the  MIXER  parameter back to the appropriate value for your vehicle (see the  Hardware Setup  page)   Set  ARM_SPIN_MOTORS  back to  1     You'll most likely want to set the  CAL_GYRO_ARM  param to  1  to enable calibrating gyros before arming   Set the  RC_ATT_MODE  parameter to set RC control mode ( 0  for rate mode,  1  for angle mode [default])  Set torque offsets as described in the  RC trim calculation  section of the Improving Performance page  Tune the controller gains as described in the  Multirotor gain tuning  section of the Improving Performance page",
            "title": "General setup"
        },
        {
            "location": "/user-guide/getting-started/#fixed-wing-specific-setup",
            "text": "Reverse servo directions if necessary using the  AIL_REV ,  ELEVATOR_REV , and  RUDDER_REV  parameters ( 1  to reverse,  0  to keep current direction)  You'll most likely want to set the  ARM_SPIN_MOTORS  parameter to  0  so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching",
            "title": "Fixed-wing-specific setup"
        },
        {
            "location": "/user-guide/hardware-setup/",
            "text": "Parts list\n\u00b6\n\n\nTo use ROSflight to its full potential, you will need the following parts on your MAV (Minature Aerial Vehicle).  ROSflight supports both multirotor and fixedwing vehicles.\n\n\n\n\nAircraft Frame, Motor(s), ESC(s), Battery and Propeller(s)\n\n\nFlight Controller (FC)\n\n\nAny external sensors\n\n\nVibration Isolation for FC\n\n\nOnboard Computer\n\n\nWi-Fi Router and Dongle\n\n\nRC transmitter and receiver\n\n\nLaptop or base station computer\n\n\nJoystick (Xbox controller)\n\n\n\n\nFrame, Motors, ESCs, Battery and Propeller\n\u00b6\n\n\nWe do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination.  There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts.\n\n\nIf you are designing your own multirotor or airplane, you may want to look at \necalc\n, an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV.\n\n\nSome things to keep in mind as you design or build your MAV.\n\n\n\n\nMost kits do not include space for an onboard computer, cameras, laser scanners or other sensors.  Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV.\n\n\nYou will likely also need to customize the power circuitry of your MAV to provide power at some specific voltage to your onboard computer.  Many people like to separate the power electronics (The ESCs and motors) from the computer and onboard sensors.  This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand.  We will talk about this more when we talk about wiring up your MAV.\n\n\nCheap propellers can cause a huge amount of vibration.  Consider buying high-quality propellers, doing a propeller balance, or both.  RCGroups, DIY Drones and Youtube have some awesome guides on how to do propeller balancing.\n\n\nESCs will need to be calibrated from 2000 to 1000 us\n\n\n\n\nFlight Controller\n\u00b6\n\n\nROSflight is best supported on the Openpilot Revolution from \nhobbyking.com\n.  It works on most variants of the revo and naze32 flight controller.  Configuring a new board is relatively straight-forward, assuming that the board uses an STM32F4xx or STM32F1xx processor.\n\n\n\n\nWarning\n\n\nWe have seen some problems using off-brand versions of flight controllers because there are fake versions of accelerometers which can mess with the firmware; try to avoid those if you can.\n\n\n\n\nExternal Sensors\n\u00b6\n\n\nAdditional Sensors you may want for your ROSflight setup include:\n\n\n\n\nSonar \u2013 MB1030 \u2013 \n$25 on MaxBotix\n\n\nGPS \u2013 u-blox NEO-M8N \u2013 \n$35 from Drotek\n\n\nDigital Airspeed Sensor \u2013 \n$65 on JDrones\n\n\n\n\nThe I2C sonar (MB124X) is also supported, but PWM sonars are preferred (\nhttps://www.adafruit.com/product/982?gclid=CjwKCAiA47DTBRAUEiwA4luU2QSNTXTLpAU6YI31w_cgVRXgiTB6v326aibrkUAaLYFRMMUWjI5uSBoCm80QAvD_BwE\n).\n\n\nVibration Isolation\n\u00b6\n\n\nIt is really important to isolate your flight controller from vibrations from propellers and motors.  We recommend using small amounts of \nKyosho Zeal\n to mount a fiberglass plate holding the FC to the MAV.  You may also want to try adding mass to the flight control board.  We have accomplished this by gluing steel washers to the fiberglass mounting plate.\n\n\n\n\nYou may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the flight control board.  The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right.\n\n\nOnboard Computer\n\u00b6\n\n\nThe only requirement for the onboard computer is that it runs Linux 16.04, ROS, has at least one USB port, and can be carried by the aircraft.  We have had success with the following onboard computers, but by no means is this a comprehensive list, it is more by way of suggestion.\n\n\n\n\nMSI CUBI \u2013 i7-5500U \u2013 \n$350 on Amazon\n\n\nGIGABYTE BRIX Gaming- i7-4710HQ/GTX 760 \u2013 \n$850 on Amazon\n\n\nIntel NUC Skullcanyon \u2013 i7-6770HQ \u2013 \n$570 on Amazon\n\n\nODROID-XU4 \u2013 Exynos5 2GHz 8-core \u2013 \n$77 on Ameridroid\n\n\nODROID-C2 \u2013 Cortex A53 2GHz 4-core \u2013 \n$42 on Ameridroid\n\n\nRasberry Pi 3 \u2013 Cortex A53 1.2GHz 4-core \u2013 \n$36 on Amazon\n\n\nNVIDIA Tegra TX1 - Cortex-A57 4-core CPU, 256-core Maxwell GPU - \n$435 from NVIDA\n (Educational Discounts Available)\n\n\n\n\nWi-Fi\n\u00b6\n\n\nYou will need Wi-Fi to communicate with your MAV when it is in the air.  ROS communicates over TCP, so it is really easy to use ROS to view what is going on in your MAV while it is flying, send commands and read sensor data.  For most applications, a standard Wi-Fi router and dongle will suffice.  For long-range applications, you may want to look into \nUbiquiti\n point-to-point Wi-Fi.  (We have seen ranges over a mile with these networks)\n\n\nRC Transmitter and Reciever\n\u00b6\n\n\nFor RC Control, you will need a transmitter with between 6 and 8 channels.  Any additional channels will be wasted.  We require RC control for safe operation, and only support arming and disarming via RC control.\n\n\nAs of version 1.0, ROSflight only supports PPM (pulse position modulation) receivers. A recommended RC setup is described below, but is meant as an example. Any configurations with PPM and 6-8 channels will be sufficient.\n\n\n\n\nTransmitter \u2013 \nFrSky Taranis QX7 ($105 on getfpv.com)\n\n\nReceiver \u2013 \nFrSky D4R-II (24.99 on getfpv.com)\n\n\n\n\nLaptop or Base Station Computer\n\u00b6\n\n\nYou will need a laptop which can run Ubuntu 16.04 and ROS to communicate with the MAV over WiFi.  If you are new to Linux, and want to also use windows, I would recommend dual booting your computer rather than using a virtual machine.\n\n\nJoystick\n\u00b6\n\n\nThe Joystick is not technically a required component, because it is possible to control your MAV over command line. It does make things easier, however.  We recommend XBOX 360 controllers and have default parameters set for the XBOX configuration.  Other joysticks are supported, but you may need to perform custom axis and button mappings.\n\n\nWiring diagram\n\u00b6\n\n\nBelow is an example wiring diagram for a multirotor using a MSI Cubi as an onboard computer.  This diagram also includes the motor power switch, which allows for the sensors, flight controller and onboard computer to be power on while the motors are off.  This is a safer way to work on the aircraft as the motors are unable to spin while the switch is off.\n\n\n\n\nYour needs will likely be slightly different than what is shown.  This is meant as an example only and can be adapted to fit your needs.\n\n\nMotor layouts\n\u00b6\n\n\nThe desired mixer can be chosen by setting the the \nMIXER\n parameter to the following values:\n\n\n\n\n\n\n\n\n#\n\n\nMixer\n\n\n\n\n\n\n\n\n\n\n0\n\n\nESC calibration\n\n\n\n\n\n\n1\n\n\nQuad +\n\n\n\n\n\n\n2\n\n\nQuad X\n\n\n\n\n\n\n3\n\n\nHex +\n\n\n\n\n\n\n4\n\n\nHex X\n\n\n\n\n\n\n5\n\n\nOcto +\n\n\n\n\n\n\n6\n\n\nOcto X\n\n\n\n\n\n\n7\n\n\nY6\n\n\n\n\n\n\n8\n\n\nX8\n\n\n\n\n\n\n9\n\n\nTricopter\n\n\n\n\n\n\n10\n\n\nFixed wing (traditional AETR)\n\n\n\n\n\n\n\n\nThe associated motor layouts are shown below for each mixer.\nThe \nESC calibration\n mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs.",
            "title": "Hardware setup"
        },
        {
            "location": "/user-guide/hardware-setup/#parts-list",
            "text": "To use ROSflight to its full potential, you will need the following parts on your MAV (Minature Aerial Vehicle).  ROSflight supports both multirotor and fixedwing vehicles.   Aircraft Frame, Motor(s), ESC(s), Battery and Propeller(s)  Flight Controller (FC)  Any external sensors  Vibration Isolation for FC  Onboard Computer  Wi-Fi Router and Dongle  RC transmitter and receiver  Laptop or base station computer  Joystick (Xbox controller)",
            "title": "Parts list"
        },
        {
            "location": "/user-guide/hardware-setup/#frame-motors-escs-battery-and-propeller",
            "text": "We do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination.  There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts.  If you are designing your own multirotor or airplane, you may want to look at  ecalc , an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV.  Some things to keep in mind as you design or build your MAV.   Most kits do not include space for an onboard computer, cameras, laser scanners or other sensors.  Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV.  You will likely also need to customize the power circuitry of your MAV to provide power at some specific voltage to your onboard computer.  Many people like to separate the power electronics (The ESCs and motors) from the computer and onboard sensors.  This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand.  We will talk about this more when we talk about wiring up your MAV.  Cheap propellers can cause a huge amount of vibration.  Consider buying high-quality propellers, doing a propeller balance, or both.  RCGroups, DIY Drones and Youtube have some awesome guides on how to do propeller balancing.  ESCs will need to be calibrated from 2000 to 1000 us",
            "title": "Frame, Motors, ESCs, Battery and Propeller"
        },
        {
            "location": "/user-guide/hardware-setup/#flight-controller",
            "text": "ROSflight is best supported on the Openpilot Revolution from  hobbyking.com .  It works on most variants of the revo and naze32 flight controller.  Configuring a new board is relatively straight-forward, assuming that the board uses an STM32F4xx or STM32F1xx processor.   Warning  We have seen some problems using off-brand versions of flight controllers because there are fake versions of accelerometers which can mess with the firmware; try to avoid those if you can.",
            "title": "Flight Controller"
        },
        {
            "location": "/user-guide/hardware-setup/#external-sensors",
            "text": "Additional Sensors you may want for your ROSflight setup include:   Sonar \u2013 MB1030 \u2013  $25 on MaxBotix  GPS \u2013 u-blox NEO-M8N \u2013  $35 from Drotek  Digital Airspeed Sensor \u2013  $65 on JDrones   The I2C sonar (MB124X) is also supported, but PWM sonars are preferred ( https://www.adafruit.com/product/982?gclid=CjwKCAiA47DTBRAUEiwA4luU2QSNTXTLpAU6YI31w_cgVRXgiTB6v326aibrkUAaLYFRMMUWjI5uSBoCm80QAvD_BwE ).",
            "title": "External Sensors"
        },
        {
            "location": "/user-guide/hardware-setup/#vibration-isolation",
            "text": "It is really important to isolate your flight controller from vibrations from propellers and motors.  We recommend using small amounts of  Kyosho Zeal  to mount a fiberglass plate holding the FC to the MAV.  You may also want to try adding mass to the flight control board.  We have accomplished this by gluing steel washers to the fiberglass mounting plate.   You may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the flight control board.  The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right.",
            "title": "Vibration Isolation"
        },
        {
            "location": "/user-guide/hardware-setup/#onboard-computer",
            "text": "The only requirement for the onboard computer is that it runs Linux 16.04, ROS, has at least one USB port, and can be carried by the aircraft.  We have had success with the following onboard computers, but by no means is this a comprehensive list, it is more by way of suggestion.   MSI CUBI \u2013 i7-5500U \u2013  $350 on Amazon  GIGABYTE BRIX Gaming- i7-4710HQ/GTX 760 \u2013  $850 on Amazon  Intel NUC Skullcanyon \u2013 i7-6770HQ \u2013  $570 on Amazon  ODROID-XU4 \u2013 Exynos5 2GHz 8-core \u2013  $77 on Ameridroid  ODROID-C2 \u2013 Cortex A53 2GHz 4-core \u2013  $42 on Ameridroid  Rasberry Pi 3 \u2013 Cortex A53 1.2GHz 4-core \u2013  $36 on Amazon  NVIDIA Tegra TX1 - Cortex-A57 4-core CPU, 256-core Maxwell GPU -  $435 from NVIDA  (Educational Discounts Available)",
            "title": "Onboard Computer"
        },
        {
            "location": "/user-guide/hardware-setup/#wi-fi",
            "text": "You will need Wi-Fi to communicate with your MAV when it is in the air.  ROS communicates over TCP, so it is really easy to use ROS to view what is going on in your MAV while it is flying, send commands and read sensor data.  For most applications, a standard Wi-Fi router and dongle will suffice.  For long-range applications, you may want to look into  Ubiquiti  point-to-point Wi-Fi.  (We have seen ranges over a mile with these networks)",
            "title": "Wi-Fi"
        },
        {
            "location": "/user-guide/hardware-setup/#rc-transmitter-and-reciever",
            "text": "For RC Control, you will need a transmitter with between 6 and 8 channels.  Any additional channels will be wasted.  We require RC control for safe operation, and only support arming and disarming via RC control.  As of version 1.0, ROSflight only supports PPM (pulse position modulation) receivers. A recommended RC setup is described below, but is meant as an example. Any configurations with PPM and 6-8 channels will be sufficient.   Transmitter \u2013  FrSky Taranis QX7 ($105 on getfpv.com)  Receiver \u2013  FrSky D4R-II (24.99 on getfpv.com)",
            "title": "RC Transmitter and Reciever"
        },
        {
            "location": "/user-guide/hardware-setup/#laptop-or-base-station-computer",
            "text": "You will need a laptop which can run Ubuntu 16.04 and ROS to communicate with the MAV over WiFi.  If you are new to Linux, and want to also use windows, I would recommend dual booting your computer rather than using a virtual machine.",
            "title": "Laptop or Base Station Computer"
        },
        {
            "location": "/user-guide/hardware-setup/#joystick",
            "text": "The Joystick is not technically a required component, because it is possible to control your MAV over command line. It does make things easier, however.  We recommend XBOX 360 controllers and have default parameters set for the XBOX configuration.  Other joysticks are supported, but you may need to perform custom axis and button mappings.",
            "title": "Joystick"
        },
        {
            "location": "/user-guide/hardware-setup/#wiring-diagram",
            "text": "Below is an example wiring diagram for a multirotor using a MSI Cubi as an onboard computer.  This diagram also includes the motor power switch, which allows for the sensors, flight controller and onboard computer to be power on while the motors are off.  This is a safer way to work on the aircraft as the motors are unable to spin while the switch is off.   Your needs will likely be slightly different than what is shown.  This is meant as an example only and can be adapted to fit your needs.",
            "title": "Wiring diagram"
        },
        {
            "location": "/user-guide/hardware-setup/#motor-layouts",
            "text": "The desired mixer can be chosen by setting the the  MIXER  parameter to the following values:     #  Mixer      0  ESC calibration    1  Quad +    2  Quad X    3  Hex +    4  Hex X    5  Octo +    6  Octo X    7  Y6    8  X8    9  Tricopter    10  Fixed wing (traditional AETR)     The associated motor layouts are shown below for each mixer.\nThe  ESC calibration  mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs.",
            "title": "Motor layouts"
        },
        {
            "location": "/user-guide/autopilot-setup/",
            "text": "Autopilot Setup\n\u00b6\n\n\nCompatible hardware\n\u00b6\n\n\nAs of January 2018 ROSflight is only supported on flight controllers with STM32F103 and STM32F405 processors, specifically, the revo, naze32, flip32.  Both the 6-DOF and 10-DOF versions of each board are fully supported.  We have had most success with revo boards purchased from \nhobbyking\n.  We have had weird issues with knock-off boards from Chinese vendors.\n\n\nFlashing firmware using the Cleanflight Configurator\n\u00b6\n\n\n\n\nDownload the latest version of ROSflight for your board \nhere\n.\n\n\nInstall the cleanflight configurator - It is an extension to Google Chrome - \nlink\n\n\nBe sure your user is in the \ndialout\n and \nplugdev\n group so you have access to the serial ports\n\nsudo usermod -a -G plugdev <username>\nsudo usermod -a -G dialout <username>\n\n\n\nDisable the modem-manager (sometimes linux thinks the device is a modem)\n\nsudo systemctl stop ModemManager.service\n\n\n\nLoad the firmware and flash using cleanflight configurator\n\n\nOpen the configurator, open firmware flasher.  Connect your flight controller, and make sure that you have selected the right port (or DFU in the case of F4-based boards).  Then select \"Load Firmware (Local)\" and  select your .hex file you downloaded earlier.\n\n\n\nShort the boot pins on your flight controller, unplug it, and and plug back in.\n\n\n\n\n\n\n\n\nIf you scroll to the bottom of the screen, you will then see the green bar indicate progress as the hex is flashed to the flight controller.  You should then see something like the following\n\n\n\n\n\n\n\nYou're done!  Great job.\n\n\n\n\n\n\n\n\nTip\n\n\nYou can completely remove the ModemManager if you don't need it, then you won't have to disable it every time you reboot.\n\nsudo apt-get purge modemmanager\n\n\n\n\n\nFlashing F4 boards from Command Line\n\u00b6\n\n\nYou can also use dfu-util to flash firmware.  This is helpful if you need (or prefer) a command-line interface.\n\n\n\n\nDownload and install dfu-util\n\nsudo apt install dfu-util\n\n\n\nMake sure you are in the dialout and plugdev group (same instructions as above)\n\n\nShort boot pins, restart the board (by unplugging and plugging back in)\n\n\nDownload the latest rosflight-F4.bin file \nhere\n.\n\n\nFlash the firmware to the device\n\n    dfu-util -a \n0\n -s 0x08000000 -D rosflight-F4.bin\n\n\n\n\n\n\n\nTip\n\n\ndfu-util auto-detects F4-based boards.  Try \ndfu-util\n -ls to make sure your board is in bootloader mode\n\n\n\n\nFlashing F1 boards from Command Line\n\u00b6\n\n\nYou can also use stm32flash to flash firmware to F1-based boards.\n\n\n\n\nDownload and install stm32flash\n\ngit clone git://git.code.sf.net/p/stm32flash/code stm32flash-code\n\ncd\n stm32flash-code\nsudo make install\n\ncd\n ..\nrm -rf stm32flash-code\n\n\n\nMake sure you are in the dialout group (same instructions as above)\n\n\nShort boot pins, restart the naze (by unplugging and plugging back in)\n\n\nDownload the latest rosflight.hex file \nhere\n.\n\n\nFlash the firmware to the proper device (replace \n/dev/ttyUSB0\n)\n\n    stm32flash -w rosflight.hex -v -g 0x0 -b \n921600\n /dev/ttyUSB0",
            "title": "Autopilot setup"
        },
        {
            "location": "/user-guide/autopilot-setup/#autopilot-setup",
            "text": "",
            "title": "Autopilot Setup"
        },
        {
            "location": "/user-guide/autopilot-setup/#compatible-hardware",
            "text": "As of January 2018 ROSflight is only supported on flight controllers with STM32F103 and STM32F405 processors, specifically, the revo, naze32, flip32.  Both the 6-DOF and 10-DOF versions of each board are fully supported.  We have had most success with revo boards purchased from  hobbyking .  We have had weird issues with knock-off boards from Chinese vendors.",
            "title": "Compatible hardware"
        },
        {
            "location": "/user-guide/autopilot-setup/#flashing-firmware-using-the-cleanflight-configurator",
            "text": "Download the latest version of ROSflight for your board  here .  Install the cleanflight configurator - It is an extension to Google Chrome -  link  Be sure your user is in the  dialout  and  plugdev  group so you have access to the serial ports sudo usermod -a -G plugdev <username>\nsudo usermod -a -G dialout <username>  Disable the modem-manager (sometimes linux thinks the device is a modem) sudo systemctl stop ModemManager.service  Load the firmware and flash using cleanflight configurator  Open the configurator, open firmware flasher.  Connect your flight controller, and make sure that you have selected the right port (or DFU in the case of F4-based boards).  Then select \"Load Firmware (Local)\" and  select your .hex file you downloaded earlier.  Short the boot pins on your flight controller, unplug it, and and plug back in.     If you scroll to the bottom of the screen, you will then see the green bar indicate progress as the hex is flashed to the flight controller.  You should then see something like the following    You're done!  Great job.     Tip  You can completely remove the ModemManager if you don't need it, then you won't have to disable it every time you reboot. sudo apt-get purge modemmanager",
            "title": "Flashing firmware using the Cleanflight Configurator"
        },
        {
            "location": "/user-guide/autopilot-setup/#flashing-f4-boards-from-command-line",
            "text": "You can also use dfu-util to flash firmware.  This is helpful if you need (or prefer) a command-line interface.   Download and install dfu-util sudo apt install dfu-util  Make sure you are in the dialout and plugdev group (same instructions as above)  Short boot pins, restart the board (by unplugging and plugging back in)  Download the latest rosflight-F4.bin file  here .  Flash the firmware to the device     dfu-util -a  0  -s 0x08000000 -D rosflight-F4.bin    Tip  dfu-util auto-detects F4-based boards.  Try  dfu-util  -ls to make sure your board is in bootloader mode",
            "title": "Flashing F4 boards from Command Line"
        },
        {
            "location": "/user-guide/autopilot-setup/#flashing-f1-boards-from-command-line",
            "text": "You can also use stm32flash to flash firmware to F1-based boards.   Download and install stm32flash git clone git://git.code.sf.net/p/stm32flash/code stm32flash-code cd  stm32flash-code\nsudo make install cd  ..\nrm -rf stm32flash-code  Make sure you are in the dialout group (same instructions as above)  Short boot pins, restart the naze (by unplugging and plugging back in)  Download the latest rosflight.hex file  here .  Flash the firmware to the proper device (replace  /dev/ttyUSB0 )     stm32flash -w rosflight.hex -v -g 0x0 -b  921600  /dev/ttyUSB0",
            "title": "Flashing F1 boards from Command Line"
        },
        {
            "location": "/user-guide/rc-configuration/",
            "text": "Binding your Transmitter to your Receiver\n\u00b6\n\n\nROSflight currently only supports PPM receivers.\n\n\nFollow the instructions in your user manual to bind your transmitter to your RC receiver.  You may also be able to find a guide on YouTube with instructions, just search for your particular transmitter and recevier model.\n\n\nRC Calibration\n\u00b6\n\n\nTo avoid confusion and to reduce code complexity in the firmware source, ROSflight does not perform software calibration of RC transmitters.  This means that RC calibration must be done on the transmitter itself, as opposed to in software.  This is pretty straight-forward in most modern transmitters.\n\n\nConfigure the full stick output for each channel\n\u00b6\n\n\nThe easiest way to this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable.  You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from \nrosflight_io\n\n\nrostopic echo /rc_raw\n\n\n\n\n\n\ncenter both sticks on your transmiterr\n\n\nApply subtrim until the first four channels all read 1500 exactly (or as close a possible, some RC recievers are worse than others and cannot exactly output 1500 us)\n\n\nSet the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us.\n\n\n\n\nYou may want to follow this YouTube guide for channel calibration in betaflight \nCalibrating RC endpoints with Taranis X9D\n.\n\n\nConfigure stick direction for roll, pitch, and yaw channels.\n\u00b6\n\n\nYou now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight.\n\n\nYou may find this graphic helpful.  It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from \nrosflight_io\n.  Make sure that the stick output is in the right direction.\n\n\n\n\nIt should be noted, that channel assignment can be modified via the \nRC_*_CHN\n parameters.  So if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same.",
            "title": "RC Configuration"
        },
        {
            "location": "/user-guide/rc-configuration/#binding-your-transmitter-to-your-receiver",
            "text": "ROSflight currently only supports PPM receivers.  Follow the instructions in your user manual to bind your transmitter to your RC receiver.  You may also be able to find a guide on YouTube with instructions, just search for your particular transmitter and recevier model.",
            "title": "Binding your Transmitter to your Receiver"
        },
        {
            "location": "/user-guide/rc-configuration/#rc-calibration",
            "text": "To avoid confusion and to reduce code complexity in the firmware source, ROSflight does not perform software calibration of RC transmitters.  This means that RC calibration must be done on the transmitter itself, as opposed to in software.  This is pretty straight-forward in most modern transmitters.",
            "title": "RC Calibration"
        },
        {
            "location": "/user-guide/rc-configuration/#configure-the-full-stick-output-for-each-channel",
            "text": "The easiest way to this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable.  You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from  rosflight_io  rostopic echo /rc_raw   center both sticks on your transmiterr  Apply subtrim until the first four channels all read 1500 exactly (or as close a possible, some RC recievers are worse than others and cannot exactly output 1500 us)  Set the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us.   You may want to follow this YouTube guide for channel calibration in betaflight  Calibrating RC endpoints with Taranis X9D .",
            "title": "Configure the full stick output for each channel"
        },
        {
            "location": "/user-guide/rc-configuration/#configure-stick-direction-for-roll-pitch-and-yaw-channels",
            "text": "You now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight.  You may find this graphic helpful.  It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from  rosflight_io .  Make sure that the stick output is in the right direction.   It should be noted, that channel assignment can be modified via the  RC_*_CHN  parameters.  So if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same.",
            "title": "Configure stick direction for roll, pitch, and yaw channels."
        },
        {
            "location": "/user-guide/ros-setup/",
            "text": "Installing/setting up ROS\n\u00b6\n\n\nYou will need to install ROS on both the onboard computer and base station laptop. Check out the \nOfficial ROS Installation\n page for details on how to do this.\n\n\nCurrently only the long-term support \nROS kinetic\n release is supported, with the recommended operating system being Ubuntu 16.04. If storage is limited on your onboard computer, you can install the bare-bones ROS package (\nros-kinetic-ros-base\n) instead of the full desktop version.\n\n\nInstalling rosflight\n\u00b6\n\n\nYou will need to install the rosflight packages on both your onboard computer and your base station computer. The onboard computer will run the node that actually communicates with the flight controller over the serial connection, while the base station needs the message and service definitions to be able to subscribe and publish to topics or call services.\n\n\nFrom the apt repository\n\u00b6\n\n\nThe recommended installation method for Ubuntu or Debian systems is to use the rosflight packages in the official ROS apt repositories. If you have configured your system to use these packages as described in the ROS installation guide, you can install rosflight using\n\nsudo apt-get install ros-kinetic-rosflight-pkgs\n\n\n\nFrom source\n\u00b6\n\n\nIf you prefer, or if you are unable to use the apt packages (e.g. for 64-bit ARM running on an NVIDA TX1/TX2), you can install the rosflight repositories from source instead. You will need a \ncatkin\n workspace set up. If you haven't already done this, you can create a new workspace with something like the following commands:\n\nsource\n /opt/ros/indigo/setup.bash\n\n\ncd\n\nmkdir -p catkin_ws/src\n\ncd\n catkin_ws/src\ncatkin_init_workspace\n\ncd\n ..\ncatkin_make\n\n\nsource\n ~/catkin_ws/devel/setup.bash\n\n\n\n\n\nNote\n\n\nIn order to ensure that ROS uses this workspace, you can add the last line (\nsource ~/catkin_ws/devel/setup.bash\n) to your \n~/.bashrc\n file or its equivalent on other systems.\n\n\n\n\nNext download the source code into your workspace\n\ncd\n ~/catkin_ws/src\ngit clone https://github.com/rosflight/rosflight.git\n\n\npull down the submodules (there is a triple-layer submodule setup in the \nrosflight\n metapackage, so you have to remember the \n--recursive\n argument)\n\ncd\n rosflight\ngit submodule --init --recursive\n\n\ninstall dependencies,\n\nrosdep install --ignore-src rosflight\n\ncd\n ~/catkin_ws/src\nrosdep install --ignore-src --from-path rosflight\n\n\nthen build the packages.\n\ncd\n ~/catkin_ws\ncatkin_make\n\n\n\nRunning rosflight_io\n\u00b6\n\n\nThe \nrosflight_io\n node is the bridge between ROS and the MAVLink communication with the flight controller. This node must be run on the computer that has the physical serial connection to your flight controller. To run this node, use something like the following command (after starting a \nroscore\n):\n\nrosrun rosflight rosflight_io _port:\n=\n/dev/ttyACM0\n\n\nReplace \n/dev/ttyACM0\n with the port your flight controller is connected to. The \nrosflight_io\n node could also be started from within a launch file with something like\n\n<node\n \npkg=\n\"rosflight\"\n \ntype=\n\"rosflight_io\"\n \nname=\n\"rosflight_io\"\n \noutput=\n\"screen\"\n>\n\n  \n<param\n \nname=\n\"port\"\n \nvalue=\n\"/dev/ttyACM0\"\n/>\n\n\n</node>\n\n\n\n\n\n\nTip\n\n\nThe optional (but recommended) \noutput=\"screen\"\n option ensures that status messages from \nrosflight_io\n will be forwarded to the console from which you call \nroslaunch\n.\n\n\n\n\nFor details on all parameters, topics, and services related to the \nrosflight_io\n node, refer to the documentation on the \nROS wiki\n.",
            "title": "ROS setup"
        },
        {
            "location": "/user-guide/ros-setup/#installingsetting-up-ros",
            "text": "You will need to install ROS on both the onboard computer and base station laptop. Check out the  Official ROS Installation  page for details on how to do this.  Currently only the long-term support  ROS kinetic  release is supported, with the recommended operating system being Ubuntu 16.04. If storage is limited on your onboard computer, you can install the bare-bones ROS package ( ros-kinetic-ros-base ) instead of the full desktop version.",
            "title": "Installing/setting up ROS"
        },
        {
            "location": "/user-guide/ros-setup/#installing-rosflight",
            "text": "You will need to install the rosflight packages on both your onboard computer and your base station computer. The onboard computer will run the node that actually communicates with the flight controller over the serial connection, while the base station needs the message and service definitions to be able to subscribe and publish to topics or call services.",
            "title": "Installing rosflight"
        },
        {
            "location": "/user-guide/ros-setup/#from-the-apt-repository",
            "text": "The recommended installation method for Ubuntu or Debian systems is to use the rosflight packages in the official ROS apt repositories. If you have configured your system to use these packages as described in the ROS installation guide, you can install rosflight using sudo apt-get install ros-kinetic-rosflight-pkgs",
            "title": "From the apt repository"
        },
        {
            "location": "/user-guide/ros-setup/#from-source",
            "text": "If you prefer, or if you are unable to use the apt packages (e.g. for 64-bit ARM running on an NVIDA TX1/TX2), you can install the rosflight repositories from source instead. You will need a  catkin  workspace set up. If you haven't already done this, you can create a new workspace with something like the following commands: source  /opt/ros/indigo/setup.bash cd \nmkdir -p catkin_ws/src cd  catkin_ws/src\ncatkin_init_workspace cd  ..\ncatkin_make source  ~/catkin_ws/devel/setup.bash   Note  In order to ensure that ROS uses this workspace, you can add the last line ( source ~/catkin_ws/devel/setup.bash ) to your  ~/.bashrc  file or its equivalent on other systems.   Next download the source code into your workspace cd  ~/catkin_ws/src\ngit clone https://github.com/rosflight/rosflight.git \npull down the submodules (there is a triple-layer submodule setup in the  rosflight  metapackage, so you have to remember the  --recursive  argument) cd  rosflight\ngit submodule --init --recursive \ninstall dependencies, rosdep install --ignore-src rosflight cd  ~/catkin_ws/src\nrosdep install --ignore-src --from-path rosflight \nthen build the packages. cd  ~/catkin_ws\ncatkin_make",
            "title": "From source"
        },
        {
            "location": "/user-guide/ros-setup/#running-rosflight_io",
            "text": "The  rosflight_io  node is the bridge between ROS and the MAVLink communication with the flight controller. This node must be run on the computer that has the physical serial connection to your flight controller. To run this node, use something like the following command (after starting a  roscore ): rosrun rosflight rosflight_io _port: = /dev/ttyACM0 \nReplace  /dev/ttyACM0  with the port your flight controller is connected to. The  rosflight_io  node could also be started from within a launch file with something like <node   pkg= \"rosflight\"   type= \"rosflight_io\"   name= \"rosflight_io\"   output= \"screen\" > \n   <param   name= \"port\"   value= \"/dev/ttyACM0\" />  </node>    Tip  The optional (but recommended)  output=\"screen\"  option ensures that status messages from  rosflight_io  will be forwarded to the console from which you call  roslaunch .   For details on all parameters, topics, and services related to the  rosflight_io  node, refer to the documentation on the  ROS wiki .",
            "title": "Running rosflight_io"
        },
        {
            "location": "/user-guide/parameter-configuration/",
            "text": "Parameters\n\u00b6\n\n\nThe ROSflight firmware has several dozen parameters which it uses to customize performance.  Parameters are considered semi-static variables.  That is, parameters do not change during flight, but they may change between vehicles.  Examples of parameters you may wish to change are:\n\n\n\n\nFixed-wing vehicle flag\n\n\nPID gains\n\n\nMixer choice\n\n\nIMU low-pass filter constant\n\n\nRC receiver type\n\n\n\n\nand so on.  All parameter access is enabled via ROS services advertised by \nrosflight_io\n while the flight controller is connected.\n\n\nParameter Interface\n\u00b6\n\n\nGetting Parameter Values\n\u00b6\n\n\nSometimes it is handy to ask the flight controller what the current value of a parameter is.  This is accomplished using the \nparam_get\n service.  As an example, let's retrieve the roll angle controller P gain.\n\n\nrosservice call /param_get PID_ROLL_ANG_P\n\n\n\n\nYou should get a response similar to (this happens to be the default value with floating-point error)\n\n\nexists\n:\n \nTrue\n\n\nvalue\n:\n \n0.15000000596\n\n\n\n\n\nChanging Parameters\n\u00b6\n\n\nParameters are changed via the \nparam_set\n service.  As an example, let's change the roll angle controller P gain.  (I will assume that the flight controller is connected and \nrosflight_io\n is running in the root namespace).\n\n\nrosservice call /param_set PID_ROLL_ANG_P 0.08\n\n\n\n\nYou should get a prompt from \nrosflight_io\n saying\n\n[ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08\n[ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters\n\n\n\nNotice that the parameters have been set, but not saved.  Parameter changes take effect immediately, however they will not persist over a reboot unless you \nwrite\n them to the non-volatile memory.  This brings us to the next task.\n\n\nWriting Parameters\n\u00b6\n\n\nTo ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory.  This is done by calling \nparam_write\n\n\nrosservice call /param_write\n\n\n\n\n\n\nError\n\n\nParameter writing can only happen if the flight controller is disarmed.  If the param write failed for some reason, you may want to make sure you are disarmed and try again.\n\n\n\n\nBacking Up and Loading Parameters from File\n\u00b6\n\n\nIt is good practice to backup your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles.  We can do this via the \nparam_save_to_file\n and \nparam_load_from_file\n services.\n\n\nFirst, let's back up our current parameter configuration:\n\n\nrosservice call /param_save_to_file ~/parameters.yml\n\n\n\n\nParameters are saved in YAML format.  You must also specify the absolute file name of where you would like your parameters to be saved.  The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller.\n\n\nNow, let's say we want to re-load this parameter file\n\nrosservice call /param_load_from_file ~/parameters.yml\n\n\nAgain, you must specify the absolute file name of the file to be loaded\n\n\nFixed-Wing Parameter Configuration\n\u00b6\n\n\nBecause ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed wing aircraft.\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nType\n\n\nFixed Wing Value\n\n\n\n\n\n\n\n\n\n\nMOTOR_PWM_UPDATE\n\n\nRefresh rate of motor commands to motors and servos (Hz) - See motor documentation\n\n\nint\n\n\n50\n\n\n\n\n\n\nARM_SPIN_MOTORS\n\n\nEnforce MOTOR_IDLE_PWM\n\n\nint\n\n\nfalse\n\n\n\n\n\n\nMOTOR_IDLE_THR\n\n\nmin throttle command sent to motors when armed (Set above 0.1 to spin when armed)\n\n\nfloat\n\n\n0.1\n\n\n\n\n\n\nARM_CHANNEL\n\n\nRC switch channel mapped to arming [0 indexed, -1 to disable]\n\n\nint\n\n\n4\n\n\n\n\n\n\nFIXED_WING\n\n\nswitches on passthrough commands for fixedwing operation\n\n\nint\n\n\ntrue\n\n\n\n\n\n\nMIXER\n\n\nWhich mixer to choose - See \nMixer documentation\n\n\nint\n\n\n10\n\n\n\n\n\n\nELEVATOR_REV\n\n\nreverses elevator servo output\n\n\nint\n\n\n0/1\n\n\n\n\n\n\nAIL_REV\n\n\nreverses aileron servo output\n\n\nint\n\n\n0/1\n\n\n\n\n\n\nRUDDER_REV\n\n\nreverses rudder servo output\n\n\nint\n\n\n0/1\n\n\n\n\n\n\nCAL_GYRO_ARM\n\n\nCalibrate gyros when arming - generally only for multirotors\n\n\nint\n\n\nfalse\n\n\n\n\n\n\n\n\nDescription of all Parameters\n\u00b6\n\n\nThis is a list of all parameters on ROSflight, their types, default values, and minimum and maximum recommended setting:\n\n\n\n\n\n\n\n\nParameter\n\n\nDescription\n\n\nType\n\n\nDefault Value\n\n\nMin\n\n\nMax\n\n\n\n\n\n\n\n\n\n\nBAUD_RATE\n\n\nBaud rate of MAVlink communication with onboard computer\n\n\nint\n\n\n921600\n\n\n9600\n\n\n921600\n\n\n\n\n\n\nSYS_ID\n\n\nMavlink System ID\n\n\nint\n\n\n1\n\n\n1\n\n\n255\n\n\n\n\n\n\nSTRM_HRTBT\n\n\nRate of heartbeat streaming (Hz)\n\n\nint\n\n\n1\n\n\n0\n\n\n1000\n\n\n\n\n\n\nSTRM_STATUS\n\n\nRate of status streaming (Hz)\n\n\nint\n\n\n10\n\n\n0\n\n\n1000\n\n\n\n\n\n\nSTRM_ATTITUDE\n\n\nRate of attitude stream (Hz)\n\n\nint\n\n\n200\n\n\n0\n\n\n1000\n\n\n\n\n\n\nSTRM_IMU\n\n\nRate of IMU stream (Hz)\n\n\nint\n\n\n500\n\n\n0\n\n\n1000\n\n\n\n\n\n\nSTRM_MAG\n\n\nRate of magnetometer stream (Hz)\n\n\nint\n\n\n50\n\n\n0\n\n\n75\n\n\n\n\n\n\nSTRM_BARO\n\n\nRate of barometer stream (Hz)\n\n\nint\n\n\n50\n\n\n0\n\n\n100\n\n\n\n\n\n\nSTRM_AIRSPEED\n\n\nRate of airspeed stream (Hz)\n\n\nint\n\n\n20\n\n\n0\n\n\n50\n\n\n\n\n\n\nSTRM_SONAR\n\n\nRate of sonar stream (Hz)\n\n\nint\n\n\n40\n\n\n0\n\n\n40\n\n\n\n\n\n\nSTRM_SERVO\n\n\nRate of raw output stream\n\n\nint\n\n\n50\n\n\n0\n\n\n490\n\n\n\n\n\n\nSTRM_RC\n\n\nRate of raw RC input stream\n\n\nint\n\n\n50\n\n\n0\n\n\n50\n\n\n\n\n\n\nPARAM_MAX_CMD\n\n\nsaturation point for PID controller output\n\n\nfloat\n\n\n1.0\n\n\n0\n\n\n1.0\n\n\n\n\n\n\nPID_ROLL_RATE_P\n\n\nRoll Rate Proportional Gain\n\n\nfloat\n\n\n0.070f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_ROLL_RATE_I\n\n\nRoll Rate Integral Gain\n\n\nfloat\n\n\n0.000f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_ROLL_RATE_D\n\n\nRall Rate Derivative Gain\n\n\nfloat\n\n\n0.000f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_PITCH_RATE_P\n\n\nPitch Rate Proporitional Gain\n\n\nfloat\n\n\n0.070f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_PITCH_RATE_I\n\n\nPitch Rate Integral Gain\n\n\nfloat\n\n\n0.0000f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_PITCH_RATE_D\n\n\nPitch Rate Derivative Gain\n\n\nfloat\n\n\n0.0000f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_YAW_RATE_P\n\n\nYaw Rate Proporitional Gain\n\n\nfloat\n\n\n0.25f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_YAW_RATE_I\n\n\nYaw Rate Integral Gain\n\n\nfloat\n\n\n0.0f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_YAW_RATE_D\n\n\nYaw Rate Derivative Gain\n\n\nfloat\n\n\n0.0f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_ROLL_ANG_P\n\n\nRoll Angle Proporitional Gain\n\n\nfloat\n\n\n0.15f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_ROLL_ANG_I\n\n\nRoll Angle Integral Gain\n\n\nfloat\n\n\n0.0f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_ROLL_ANG_D\n\n\nRoll Angle Derivative Gain\n\n\nfloat\n\n\n0.05f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_PITCH_ANG_P\n\n\nPitch Angle Proporitional Gain\n\n\nfloat\n\n\n0.15f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_PITCH_ANG_I\n\n\nPitch Angle Integral Gain\n\n\nfloat\n\n\n0.0f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nPID_PITCH_ANG_D\n\n\nPitch Angle Derivative Gain\n\n\nfloat\n\n\n0.05f\n\n\n0.0\n\n\n1000.0\n\n\n\n\n\n\nX_EQ_TORQUE\n\n\nEquilibrium torque added to output of controller on x axis\n\n\nfloat\n\n\n0.0f\n\n\n-1.0\n\n\n1.0\n\n\n\n\n\n\nY_EQ_TORQUE\n\n\nEquilibrium torque added to output of controller on y axis\n\n\nfloat\n\n\n0.0f\n\n\n-1.0\n\n\n1.0\n\n\n\n\n\n\nZ_EQ_TORQUE\n\n\nEquilibrium torque added to output of controller on z axis\n\n\nfloat\n\n\n0.0f\n\n\n-1.0\n\n\n1.0\n\n\n\n\n\n\nPID_TAU\n\n\nDirty Derivative time constant - See controller documentation\n\n\nfloat\n\n\n0.05f\n\n\n0.0\n\n\n1.0\n\n\n\n\n\n\nMOTOR_PWM_UPDATE\n\n\nRefresh rate of motor commands to motors - See motor documentation\n\n\nint\n\n\n490\n\n\n0\n\n\n1000\n\n\n\n\n\n\nMOTOR_IDLE_THR\n\n\nmin throttle command sent to motors when armed (Set above 0.1 to spin when armed)\n\n\nfloat\n\n\n0.1\n\n\n0.0\n\n\n1.0\n\n\n\n\n\n\nFAILSAFE_THR\n\n\nThrottle sent to motors in failsafe condition (set just below hover throttle)\n\n\nfloat\n\n\n0.3\n\n\n0.0\n\n\n1.0\n\n\n\n\n\n\nMOTOR_MIN_PWM\n\n\nPWM value sent to motor ESCs at zero throttle\n\n\nint\n\n\n1000\n\n\n1000\n\n\n2000\n\n\n\n\n\n\nMOTOR_MAX_PWM\n\n\nPWM value sent to motor ESCs at full throttle\n\n\nint\n\n\n2000\n\n\n1000\n\n\n2000\n\n\n\n\n\n\nARM_SPIN_MOTORS\n\n\nEnforce MOTOR_IDLE_THR\n\n\nint\n\n\ntrue\n\n\n0\n\n\n1\n\n\n\n\n\n\nFILTER_INIT_T\n\n\nTime in ms to initialize estimator\n\n\nint\n\n\n3000\n\n\n0\n\n\n100000\n\n\n\n\n\n\nFILTER_KP\n\n\nestimator proportional gain - See estimator documentation\n\n\nfloat\n\n\n0.5f\n\n\n0\n\n\n10.0\n\n\n\n\n\n\nFILTER_KI\n\n\nestimator integral gain - See estimator documentation\n\n\nfloat\n\n\n0.05f\n\n\n0\n\n\n1.0\n\n\n\n\n\n\nFILTER_QUAD_INT\n\n\nPerform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors)\n\n\nint\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n\n\nFILTER_MAT_EXP\n\n\n1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration\n\n\nint\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n\n\nFILTER_USE_ACC\n\n\nUse accelerometer to correct gyro integration drift (adds ~70 us to estimation loop)\n\n\nint\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n\n\nCAL_GYRO_ARM\n\n\nTrue if desired to calibrate gyros on arm\n\n\nint\n\n\nfalse\n\n\n0\n\n\n1\n\n\n\n\n\n\nGYRO_LPF_ALPHA\n\n\nLow-pass filter constant - See estimator documentation\n\n\nfloat\n\n\n0.3f\n\n\n0\n\n\n1.0\n\n\n\n\n\n\nACC_LPF_ALPHA\n\n\nLow-pass filter constant - See estimator documentation\n\n\nfloat\n\n\n0.5f\n\n\n0\n\n\n1.0\n\n\n\n\n\n\nGYRO_X_BIAS\n\n\nConstant x-bias of gyroscope readings\n\n\nfloat\n\n\n0.0f\n\n\n-1.0\n\n\n1.0\n\n\n\n\n\n\nGYRO_Y_BIAS\n\n\nConstant y-bias of gyroscope readings\n\n\nfloat\n\n\n0.0f\n\n\n-1.0\n\n\n1.0\n\n\n\n\n\n\nGYRO_Z_BIAS\n\n\nConstant z-bias of gyroscope readings\n\n\nfloat\n\n\n0.0f\n\n\n-1.0\n\n\n1.0\n\n\n\n\n\n\nACC_X_BIAS\n\n\nConstant x-bias of accelerometer readings\n\n\nfloat\n\n\n0.0f\n\n\n-2.0\n\n\n2.0\n\n\n\n\n\n\nACC_Y_BIAS\n\n\nConstant y-bias of accelerometer readings\n\n\nfloat\n\n\n0.0f\n\n\n-2.0\n\n\n2.0\n\n\n\n\n\n\nACC_Z_BIAS\n\n\nConstant z-bias of accelerometer readings\n\n\nfloat\n\n\n0.0f\n\n\n-2.0\n\n\n2.0\n\n\n\n\n\n\nACC_X_TEMP_COMP\n\n\nLinear x-axis temperature compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-2.0\n\n\n2.0\n\n\n\n\n\n\nACC_Y_TEMP_COMP\n\n\nLinear y-axis temperature compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-2.0\n\n\n2.0\n\n\n\n\n\n\nACC_Z_TEMP_COMP\n\n\nLinear z-axis temperature compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-2.0\n\n\n2.0\n\n\n\n\n\n\nMAG_A11_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n1.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A12_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A13_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A21_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A22_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n1.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A23_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A31_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A32_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_A33_COMP\n\n\nSoft iron compensation constant\n\n\nfloat\n\n\n1.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_X_BIAS\n\n\nHard iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_Y_BIAS\n\n\nHard iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nMAG_Z_BIAS\n\n\nHard iron compensation constant\n\n\nfloat\n\n\n0.0f\n\n\n-999.0\n\n\n999.0\n\n\n\n\n\n\nBARO_BIAS\n\n\nBarometer measurement bias (Pa)\n\n\nfloat\n\n\n0.0f\n\n\n0\n\n\ninf\n\n\n\n\n\n\nGROUND_LEVEL\n\n\nAltitude of ground level (m)\n\n\nfloat\n\n\n1387.0f\n\n\n-1000\n\n\n10000\n\n\n\n\n\n\nDIFF_PRESS_BIAS\n\n\nDifferential Pressure Bias (Pa)\n\n\nfloat\n\n\n0.0f\n\n\n-10\n\n\n10\n\n\n\n\n\n\nRC_TYPE\n\n\nType of RC input 0 - Parallel PWM (PWM), 1 - Pulse-Position Modulation (PPM)\n\n\nint\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n\n\nRC_X_CHN\n\n\nRC input channel mapped to x-axis commands [0 - indexed]\n\n\nint\n\n\n0\n\n\n0\n\n\n3\n\n\n\n\n\n\nRC_Y_CHN\n\n\nRC input channel mapped to y-axis commands [0 - indexed]\n\n\nint\n\n\n1\n\n\n0\n\n\n3\n\n\n\n\n\n\nRC_Z_CHN\n\n\nRC input channel mapped to z-axis commands [0 - indexed]\n\n\nint\n\n\n3\n\n\n0\n\n\n3\n\n\n\n\n\n\nRC_F_CHN\n\n\nRC input channel mapped to F-axis commands [0 - indexed]\n\n\nint\n\n\n2\n\n\n0\n\n\n3\n\n\n\n\n\n\nRC_ATT_OVRD_CHN\n\n\nRC switch mapped to attitude override [0 indexed, -1 to disable]\n\n\nint\n\n\n4\n\n\n4\n\n\n7\n\n\n\n\n\n\nRC_THR_OVRD_CHN\n\n\nRC switch channel mapped to throttle override [0 indexed, -1 to disable]\n\n\nint\n\n\n4\n\n\n4\n\n\n7\n\n\n\n\n\n\nRC_ATT_CTRL_CHN\n\n\nRC switch channel mapped to attitude control type [0 indexed, -1 to disable]\n\n\nint\n\n\n-1\n\n\n4\n\n\n7\n\n\n\n\n\n\nARM_CHANNEL\n\n\nRC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable]\n\n\nint\n\n\n-1\n\n\n4\n\n\n7\n\n\n\n\n\n\nRC_NUM_CHN\n\n\nnumber of RC input channels\n\n\nint\n\n\n6\n\n\n1\n\n\n8\n\n\n\n\n\n\nSWITCH_5_DIR\n\n\nRC switch 5 toggle direction\n\n\nint\n\n\n1\n\n\n-1\n\n\n1\n\n\n\n\n\n\nSWITCH_6_DIR\n\n\nRC switch 6 toggle direction\n\n\nint\n\n\n1\n\n\n-1\n\n\n1\n\n\n\n\n\n\nSWITCH_7_DIR\n\n\nRC switch 7 toggle direction\n\n\nint\n\n\n1\n\n\n-1\n\n\n1\n\n\n\n\n\n\nSWITCH_8_DIR\n\n\nRC switch 8 toggle direction\n\n\nint\n\n\n1\n\n\n-1\n\n\n1\n\n\n\n\n\n\nRC_OVRD_DEV\n\n\nRC stick deviation from center for overrride\n\n\nfloat\n\n\n0.1\n\n\n0.0\n\n\n1.0\n\n\n\n\n\n\nOVRD_LAG_TIME\n\n\nRC stick deviation lag time before returning control (ms)\n\n\nint\n\n\n1000\n\n\n0\n\n\n100000\n\n\n\n\n\n\nMIN_THROTTLE\n\n\nTake minimum throttle between RC and computer at all times\n\n\nint\n\n\ntrue\n\n\n0\n\n\n1\n\n\n\n\n\n\nRC_ATT_MODE\n\n\nAttitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set.\n\n\nint\n\n\n1\n\n\n0\n\n\n1\n\n\n\n\n\n\nRC_MAX_ROLL\n\n\nMaximum roll angle command sent by full deflection of RC sticks\n\n\nfloat\n\n\n0.786f\n\n\n0.0\n\n\n3.14159\n\n\n\n\n\n\nRC_MAX_PITCH\n\n\nMaximum pitch angle command sent by full stick deflection of RC sticks\n\n\nfloat\n\n\n0.786f\n\n\n0.0\n\n\n3.14159\n\n\n\n\n\n\nRC_MAX_ROLLRATE\n\n\nMaximum roll rate command sent by full stick deflection of RC sticks\n\n\nfloat\n\n\n3.14159f\n\n\n0.0\n\n\n9.42477796077\n\n\n\n\n\n\nRC_MAX_PITCHRATE\n\n\nMaximum pitch command sent by full stick deflection of RC sticks\n\n\nfloat\n\n\n3.14159f\n\n\n0.0\n\n\n3.14159\n\n\n\n\n\n\nRC_MAX_YAWRATE\n\n\nMaximum pitch command sent by full stick deflection of RC sticks\n\n\nfloat\n\n\n1.507f\n\n\n0.0\n\n\n3.14159\n\n\n\n\n\n\nMIXER\n\n\nWhich mixer to choose - See Mixer documentation\n\n\nint\n\n\nMixer::INVALID_MIXER\n\n\n0\n\n\n10\n\n\n\n\n\n\nFIXED_WING\n\n\nswitches on passthrough commands for fixedwing operation\n\n\nint\n\n\nfalse\n\n\n0\n\n\n1\n\n\n\n\n\n\nELEVATOR_REV\n\n\nreverses elevator servo output\n\n\nint\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n\nAIL_REV\n\n\nreverses aileron servo output\n\n\nint\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n\nRUDDER_REV\n\n\nreverses rudder servo output\n\n\nint\n\n\n0\n\n\n0\n\n\n1\n\n\n\n\n\n\nARM_THRESHOLD\n\n\nRC deviation from max/min in yaw and throttle for arming and disarming check (us)\n\n\nfloat\n\n\n0.15\n\n\n0\n\n\n500",
            "title": "Parameter Configuration"
        },
        {
            "location": "/user-guide/parameter-configuration/#parameters",
            "text": "The ROSflight firmware has several dozen parameters which it uses to customize performance.  Parameters are considered semi-static variables.  That is, parameters do not change during flight, but they may change between vehicles.  Examples of parameters you may wish to change are:   Fixed-wing vehicle flag  PID gains  Mixer choice  IMU low-pass filter constant  RC receiver type   and so on.  All parameter access is enabled via ROS services advertised by  rosflight_io  while the flight controller is connected.",
            "title": "Parameters"
        },
        {
            "location": "/user-guide/parameter-configuration/#parameter-interface",
            "text": "",
            "title": "Parameter Interface"
        },
        {
            "location": "/user-guide/parameter-configuration/#getting-parameter-values",
            "text": "Sometimes it is handy to ask the flight controller what the current value of a parameter is.  This is accomplished using the  param_get  service.  As an example, let's retrieve the roll angle controller P gain.  rosservice call /param_get PID_ROLL_ANG_P  You should get a response similar to (this happens to be the default value with floating-point error)  exists :   True  value :   0.15000000596",
            "title": "Getting Parameter Values"
        },
        {
            "location": "/user-guide/parameter-configuration/#changing-parameters",
            "text": "Parameters are changed via the  param_set  service.  As an example, let's change the roll angle controller P gain.  (I will assume that the flight controller is connected and  rosflight_io  is running in the root namespace).  rosservice call /param_set PID_ROLL_ANG_P 0.08  You should get a prompt from  rosflight_io  saying [ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08\n[ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters  Notice that the parameters have been set, but not saved.  Parameter changes take effect immediately, however they will not persist over a reboot unless you  write  them to the non-volatile memory.  This brings us to the next task.",
            "title": "Changing Parameters"
        },
        {
            "location": "/user-guide/parameter-configuration/#writing-parameters",
            "text": "To ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory.  This is done by calling  param_write  rosservice call /param_write   Error  Parameter writing can only happen if the flight controller is disarmed.  If the param write failed for some reason, you may want to make sure you are disarmed and try again.",
            "title": "Writing Parameters"
        },
        {
            "location": "/user-guide/parameter-configuration/#backing-up-and-loading-parameters-from-file",
            "text": "It is good practice to backup your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles.  We can do this via the  param_save_to_file  and  param_load_from_file  services.  First, let's back up our current parameter configuration:  rosservice call /param_save_to_file ~/parameters.yml  Parameters are saved in YAML format.  You must also specify the absolute file name of where you would like your parameters to be saved.  The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller.  Now, let's say we want to re-load this parameter file rosservice call /param_load_from_file ~/parameters.yml \nAgain, you must specify the absolute file name of the file to be loaded",
            "title": "Backing Up and Loading Parameters from File"
        },
        {
            "location": "/user-guide/parameter-configuration/#fixed-wing-parameter-configuration",
            "text": "Because ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed wing aircraft.     Parameter  Description  Type  Fixed Wing Value      MOTOR_PWM_UPDATE  Refresh rate of motor commands to motors and servos (Hz) - See motor documentation  int  50    ARM_SPIN_MOTORS  Enforce MOTOR_IDLE_PWM  int  false    MOTOR_IDLE_THR  min throttle command sent to motors when armed (Set above 0.1 to spin when armed)  float  0.1    ARM_CHANNEL  RC switch channel mapped to arming [0 indexed, -1 to disable]  int  4    FIXED_WING  switches on passthrough commands for fixedwing operation  int  true    MIXER  Which mixer to choose - See  Mixer documentation  int  10    ELEVATOR_REV  reverses elevator servo output  int  0/1    AIL_REV  reverses aileron servo output  int  0/1    RUDDER_REV  reverses rudder servo output  int  0/1    CAL_GYRO_ARM  Calibrate gyros when arming - generally only for multirotors  int  false",
            "title": "Fixed-Wing Parameter Configuration"
        },
        {
            "location": "/user-guide/parameter-configuration/#description-of-all-parameters",
            "text": "This is a list of all parameters on ROSflight, their types, default values, and minimum and maximum recommended setting:     Parameter  Description  Type  Default Value  Min  Max      BAUD_RATE  Baud rate of MAVlink communication with onboard computer  int  921600  9600  921600    SYS_ID  Mavlink System ID  int  1  1  255    STRM_HRTBT  Rate of heartbeat streaming (Hz)  int  1  0  1000    STRM_STATUS  Rate of status streaming (Hz)  int  10  0  1000    STRM_ATTITUDE  Rate of attitude stream (Hz)  int  200  0  1000    STRM_IMU  Rate of IMU stream (Hz)  int  500  0  1000    STRM_MAG  Rate of magnetometer stream (Hz)  int  50  0  75    STRM_BARO  Rate of barometer stream (Hz)  int  50  0  100    STRM_AIRSPEED  Rate of airspeed stream (Hz)  int  20  0  50    STRM_SONAR  Rate of sonar stream (Hz)  int  40  0  40    STRM_SERVO  Rate of raw output stream  int  50  0  490    STRM_RC  Rate of raw RC input stream  int  50  0  50    PARAM_MAX_CMD  saturation point for PID controller output  float  1.0  0  1.0    PID_ROLL_RATE_P  Roll Rate Proportional Gain  float  0.070f  0.0  1000.0    PID_ROLL_RATE_I  Roll Rate Integral Gain  float  0.000f  0.0  1000.0    PID_ROLL_RATE_D  Rall Rate Derivative Gain  float  0.000f  0.0  1000.0    PID_PITCH_RATE_P  Pitch Rate Proporitional Gain  float  0.070f  0.0  1000.0    PID_PITCH_RATE_I  Pitch Rate Integral Gain  float  0.0000f  0.0  1000.0    PID_PITCH_RATE_D  Pitch Rate Derivative Gain  float  0.0000f  0.0  1000.0    PID_YAW_RATE_P  Yaw Rate Proporitional Gain  float  0.25f  0.0  1000.0    PID_YAW_RATE_I  Yaw Rate Integral Gain  float  0.0f  0.0  1000.0    PID_YAW_RATE_D  Yaw Rate Derivative Gain  float  0.0f  0.0  1000.0    PID_ROLL_ANG_P  Roll Angle Proporitional Gain  float  0.15f  0.0  1000.0    PID_ROLL_ANG_I  Roll Angle Integral Gain  float  0.0f  0.0  1000.0    PID_ROLL_ANG_D  Roll Angle Derivative Gain  float  0.05f  0.0  1000.0    PID_PITCH_ANG_P  Pitch Angle Proporitional Gain  float  0.15f  0.0  1000.0    PID_PITCH_ANG_I  Pitch Angle Integral Gain  float  0.0f  0.0  1000.0    PID_PITCH_ANG_D  Pitch Angle Derivative Gain  float  0.05f  0.0  1000.0    X_EQ_TORQUE  Equilibrium torque added to output of controller on x axis  float  0.0f  -1.0  1.0    Y_EQ_TORQUE  Equilibrium torque added to output of controller on y axis  float  0.0f  -1.0  1.0    Z_EQ_TORQUE  Equilibrium torque added to output of controller on z axis  float  0.0f  -1.0  1.0    PID_TAU  Dirty Derivative time constant - See controller documentation  float  0.05f  0.0  1.0    MOTOR_PWM_UPDATE  Refresh rate of motor commands to motors - See motor documentation  int  490  0  1000    MOTOR_IDLE_THR  min throttle command sent to motors when armed (Set above 0.1 to spin when armed)  float  0.1  0.0  1.0    FAILSAFE_THR  Throttle sent to motors in failsafe condition (set just below hover throttle)  float  0.3  0.0  1.0    MOTOR_MIN_PWM  PWM value sent to motor ESCs at zero throttle  int  1000  1000  2000    MOTOR_MAX_PWM  PWM value sent to motor ESCs at full throttle  int  2000  1000  2000    ARM_SPIN_MOTORS  Enforce MOTOR_IDLE_THR  int  true  0  1    FILTER_INIT_T  Time in ms to initialize estimator  int  3000  0  100000    FILTER_KP  estimator proportional gain - See estimator documentation  float  0.5f  0  10.0    FILTER_KI  estimator integral gain - See estimator documentation  float  0.05f  0  1.0    FILTER_QUAD_INT  Perform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors)  int  1  0  1    FILTER_MAT_EXP  1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration  int  1  0  1    FILTER_USE_ACC  Use accelerometer to correct gyro integration drift (adds ~70 us to estimation loop)  int  1  0  1    CAL_GYRO_ARM  True if desired to calibrate gyros on arm  int  false  0  1    GYRO_LPF_ALPHA  Low-pass filter constant - See estimator documentation  float  0.3f  0  1.0    ACC_LPF_ALPHA  Low-pass filter constant - See estimator documentation  float  0.5f  0  1.0    GYRO_X_BIAS  Constant x-bias of gyroscope readings  float  0.0f  -1.0  1.0    GYRO_Y_BIAS  Constant y-bias of gyroscope readings  float  0.0f  -1.0  1.0    GYRO_Z_BIAS  Constant z-bias of gyroscope readings  float  0.0f  -1.0  1.0    ACC_X_BIAS  Constant x-bias of accelerometer readings  float  0.0f  -2.0  2.0    ACC_Y_BIAS  Constant y-bias of accelerometer readings  float  0.0f  -2.0  2.0    ACC_Z_BIAS  Constant z-bias of accelerometer readings  float  0.0f  -2.0  2.0    ACC_X_TEMP_COMP  Linear x-axis temperature compensation constant  float  0.0f  -2.0  2.0    ACC_Y_TEMP_COMP  Linear y-axis temperature compensation constant  float  0.0f  -2.0  2.0    ACC_Z_TEMP_COMP  Linear z-axis temperature compensation constant  float  0.0f  -2.0  2.0    MAG_A11_COMP  Soft iron compensation constant  float  1.0f  -999.0  999.0    MAG_A12_COMP  Soft iron compensation constant  float  0.0f  -999.0  999.0    MAG_A13_COMP  Soft iron compensation constant  float  0.0f  -999.0  999.0    MAG_A21_COMP  Soft iron compensation constant  float  0.0f  -999.0  999.0    MAG_A22_COMP  Soft iron compensation constant  float  1.0f  -999.0  999.0    MAG_A23_COMP  Soft iron compensation constant  float  0.0f  -999.0  999.0    MAG_A31_COMP  Soft iron compensation constant  float  0.0f  -999.0  999.0    MAG_A32_COMP  Soft iron compensation constant  float  0.0f  -999.0  999.0    MAG_A33_COMP  Soft iron compensation constant  float  1.0f  -999.0  999.0    MAG_X_BIAS  Hard iron compensation constant  float  0.0f  -999.0  999.0    MAG_Y_BIAS  Hard iron compensation constant  float  0.0f  -999.0  999.0    MAG_Z_BIAS  Hard iron compensation constant  float  0.0f  -999.0  999.0    BARO_BIAS  Barometer measurement bias (Pa)  float  0.0f  0  inf    GROUND_LEVEL  Altitude of ground level (m)  float  1387.0f  -1000  10000    DIFF_PRESS_BIAS  Differential Pressure Bias (Pa)  float  0.0f  -10  10    RC_TYPE  Type of RC input 0 - Parallel PWM (PWM), 1 - Pulse-Position Modulation (PPM)  int  1  0  1    RC_X_CHN  RC input channel mapped to x-axis commands [0 - indexed]  int  0  0  3    RC_Y_CHN  RC input channel mapped to y-axis commands [0 - indexed]  int  1  0  3    RC_Z_CHN  RC input channel mapped to z-axis commands [0 - indexed]  int  3  0  3    RC_F_CHN  RC input channel mapped to F-axis commands [0 - indexed]  int  2  0  3    RC_ATT_OVRD_CHN  RC switch mapped to attitude override [0 indexed, -1 to disable]  int  4  4  7    RC_THR_OVRD_CHN  RC switch channel mapped to throttle override [0 indexed, -1 to disable]  int  4  4  7    RC_ATT_CTRL_CHN  RC switch channel mapped to attitude control type [0 indexed, -1 to disable]  int  -1  4  7    ARM_CHANNEL  RC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable]  int  -1  4  7    RC_NUM_CHN  number of RC input channels  int  6  1  8    SWITCH_5_DIR  RC switch 5 toggle direction  int  1  -1  1    SWITCH_6_DIR  RC switch 6 toggle direction  int  1  -1  1    SWITCH_7_DIR  RC switch 7 toggle direction  int  1  -1  1    SWITCH_8_DIR  RC switch 8 toggle direction  int  1  -1  1    RC_OVRD_DEV  RC stick deviation from center for overrride  float  0.1  0.0  1.0    OVRD_LAG_TIME  RC stick deviation lag time before returning control (ms)  int  1000  0  100000    MIN_THROTTLE  Take minimum throttle between RC and computer at all times  int  true  0  1    RC_ATT_MODE  Attitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set.  int  1  0  1    RC_MAX_ROLL  Maximum roll angle command sent by full deflection of RC sticks  float  0.786f  0.0  3.14159    RC_MAX_PITCH  Maximum pitch angle command sent by full stick deflection of RC sticks  float  0.786f  0.0  3.14159    RC_MAX_ROLLRATE  Maximum roll rate command sent by full stick deflection of RC sticks  float  3.14159f  0.0  9.42477796077    RC_MAX_PITCHRATE  Maximum pitch command sent by full stick deflection of RC sticks  float  3.14159f  0.0  3.14159    RC_MAX_YAWRATE  Maximum pitch command sent by full stick deflection of RC sticks  float  1.507f  0.0  3.14159    MIXER  Which mixer to choose - See Mixer documentation  int  Mixer::INVALID_MIXER  0  10    FIXED_WING  switches on passthrough commands for fixedwing operation  int  false  0  1    ELEVATOR_REV  reverses elevator servo output  int  0  0  1    AIL_REV  reverses aileron servo output  int  0  0  1    RUDDER_REV  reverses rudder servo output  int  0  0  1    ARM_THRESHOLD  RC deviation from max/min in yaw and throttle for arming and disarming check (us)  float  0.15  0  500",
            "title": "Description of all Parameters"
        },
        {
            "location": "/user-guide/preflight-checks/",
            "text": "Pre-Flight Checklist\n\u00b6\n\n\nThis is an example of a ROSflight pre-flight checklist.  You will likely need to augment this with checks specific to your hardware and the code running on the onboard computer.\n\n\nGeneric Checklist\n\u00b6\n\n\nBefore powering up motors\n\u00b6\n\n\n\n\nROS is running on onboard computer, communicating with base station\n\n\nSensors are calibrated and publishing\n\n\nIMU (re-calibrate every flight): \nrosservice call /calibrate_imu\n\n\nBarometer: \nrosservice call /calibrate_baro\n\n\nSonar (if attached)\n\n\nAirspeed (if attached)\n\n\n\n\n\n\nEstimated attitude is being published and looks accurate\n\n\nRC communication\n\n\nArming and disarming\n\n\nPublished outputs look reasonable\n\n\nFailsafe behavior\n\n\nRC override behavior\n\n\nRC range test\n\n\nWire-wiggle test (wiggle all wires to look for bad connections)\n\n\nParameter Check (if using a fixed wing, there are about 8 parameter you will need to change from default  )\n\n\n\n\nAfter Powering Up Motors\n\u00b6\n\n\n\n\nWarning\n\n\nBe sure flight controller is disarmed before powering up motors!!!\n\n\n\n\n\n\nArm/Disarm test\n\n\nPropeller spin test (check directions and response to stick inputs)\n\n\nControl surface test (Fixed Wing)\n\n\nResponse to offboard controls\n\n\n\n\nROSplane Checklist\n\u00b6\n\n\nBefore Leaving for the Flying Field\n\u00b6\n\n\n\n\nROS is running and communicating on both the base station and onboard computer\n\n\nSet fixed wing parameters\n\n\nWireless network setup is working\n\n\nrosflight_io\n reports no errors\n\n\nRC communication and override check\n\n\nProper directions on all control surfaces, from both RC and onboard computer\n\n\nFailsafe behavior is working\n\n\nlogging is set up and working (automatic rosbag recording)\n\n\nblow into pitot tube and watch airspeed estimate\n\n\nmove aircraft up and down and watch altitude estimate (remember NED, so higher altitude = negative z)\n\n\ncheck for GPS fix (go outside)\n\n\nwire-wiggle test (look for sensor or RC dropout and brownouts when wiggling all wires - watch output from \nrosflight_io\n for potential errors)\n\n\nwalking estimator test (walk around outside with GPS and airspeed and watch estimator)\n\n\n\n\nAfter getting to flying field\n\u00b6\n\n\n\n\nSet up Network\n\n\nCheck RC communication\n\n\nPublish Commands to aircraft, check response\n\n\nCheck RC switch setup\n\n\nArm/Disarm Test\n\n\nGPS fix\n\n\nCheck automatic logging\n\n\nStart external video recording\n\n\nFly!",
            "title": "Preflight checks"
        },
        {
            "location": "/user-guide/preflight-checks/#pre-flight-checklist",
            "text": "This is an example of a ROSflight pre-flight checklist.  You will likely need to augment this with checks specific to your hardware and the code running on the onboard computer.",
            "title": "Pre-Flight Checklist"
        },
        {
            "location": "/user-guide/preflight-checks/#generic-checklist",
            "text": "",
            "title": "Generic Checklist"
        },
        {
            "location": "/user-guide/preflight-checks/#before-powering-up-motors",
            "text": "ROS is running on onboard computer, communicating with base station  Sensors are calibrated and publishing  IMU (re-calibrate every flight):  rosservice call /calibrate_imu  Barometer:  rosservice call /calibrate_baro  Sonar (if attached)  Airspeed (if attached)    Estimated attitude is being published and looks accurate  RC communication  Arming and disarming  Published outputs look reasonable  Failsafe behavior  RC override behavior  RC range test  Wire-wiggle test (wiggle all wires to look for bad connections)  Parameter Check (if using a fixed wing, there are about 8 parameter you will need to change from default  )",
            "title": "Before powering up motors"
        },
        {
            "location": "/user-guide/preflight-checks/#after-powering-up-motors",
            "text": "Warning  Be sure flight controller is disarmed before powering up motors!!!    Arm/Disarm test  Propeller spin test (check directions and response to stick inputs)  Control surface test (Fixed Wing)  Response to offboard controls",
            "title": "After Powering Up Motors"
        },
        {
            "location": "/user-guide/preflight-checks/#rosplane-checklist",
            "text": "",
            "title": "ROSplane Checklist"
        },
        {
            "location": "/user-guide/preflight-checks/#before-leaving-for-the-flying-field",
            "text": "ROS is running and communicating on both the base station and onboard computer  Set fixed wing parameters  Wireless network setup is working  rosflight_io  reports no errors  RC communication and override check  Proper directions on all control surfaces, from both RC and onboard computer  Failsafe behavior is working  logging is set up and working (automatic rosbag recording)  blow into pitot tube and watch airspeed estimate  move aircraft up and down and watch altitude estimate (remember NED, so higher altitude = negative z)  check for GPS fix (go outside)  wire-wiggle test (look for sensor or RC dropout and brownouts when wiggling all wires - watch output from  rosflight_io  for potential errors)  walking estimator test (walk around outside with GPS and airspeed and watch estimator)",
            "title": "Before Leaving for the Flying Field"
        },
        {
            "location": "/user-guide/preflight-checks/#after-getting-to-flying-field",
            "text": "Set up Network  Check RC communication  Publish Commands to aircraft, check response  Check RC switch setup  Arm/Disarm Test  GPS fix  Check automatic logging  Start external video recording  Fly!",
            "title": "After getting to flying field"
        },
        {
            "location": "/user-guide/performance/",
            "text": "Improving Performance\n\u00b6\n\n\nROSflight supplies several methods to improve the performance of your aircraft.  Tuning gains, adding feed-forward torques and tuning the estimator are three ways to get your aircraft flying great!\n\n\nGain Tuning\n\u00b6\n\n\nBecause there are a wide variety of multirotors out there, no one set of PID controller gains will work for all vehicles.  The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases, however, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably.  There are some great tutorials online on multirotor gain tuning, this is another tried-and-true method used to great effect at BYU.\n\n\nIf you are unfamiliar with PIDs, then you should probably go read about them before trying to tune a multirotor.  Getting an understanding for what is going on will definitely guide your decision making process as you try to figure out better gains.\n\n\nWhile tuning controller gains, there is a very likely scenario that the multirotor will oscillate out of control.  To handle that, I generally add what I call \"training wheels\" to the multirotors I'm tuning, which amounts to thin carbon rods in the shape of an X zip-tied to the landing gear.  This widens out the base of the quadcopter so if you come down on a hard oscillation, chances are you'll end up upright, hopefully without a prop strike.  Here is a video of the maiden flight of ROSflight with \"training wheels\" attached.\n\n\n\n\n\nNow, for the procedure on tuning.\n\n\nTuning Roll and Pitch\n\u00b6\n\n\nHere is a flowchart describing my PID tuning process for roll and pitch:\n\n\n\n\nYou may want to do another D-tuning iteration, and sometimes it is helpful to do a little tweaking to eek out a little performance from the differences in roll and pitch dynamics.\n\n\nNotice, I didn't include any I tuning.  As a general rule, try to keep the I gain as low as possible.  It will \nalways\n slow your reponse rate to input, and it can induce low frequency oscillations.\n\n\nYou should \nonly\n have I gain on roll and pitch if one of the following is true:\n\n\n\n\nYou expect your CG to change or\n\n\nyou expect your rotor geometry to change.\n\n\n\n\nBoth of these are pretty rare.  Instead, use your RC transmitter to trim the aircraft so it hovers on no stick input.  In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on roll, pitch and yawrate.\n\n\nTuning Yawrate\n\u00b6\n\n\nDynamically and algorithmically speaking, there is really not much advantage to using a D gain in yawrate.  Controlling with derivative requires differentiating gyro input, which tends to be pretty noisy.  In our experience, putting D in rate controllers on multirotors has always decreased performance.\n\n\nTuning Yawrate is generally pretty easy, basically, keep cranking it up until you feel like it's \"locked in\".  Sometimes a little bit of I (on the order of 0.1P) can help with this as well.\n\n\nThe problem with too much P on yawrate generally manifests itself in motor saturation.  Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat.  After you're done tuning, you might want to look at a plot of motor outputs during a fairly agressive flight.  Underactuated yaw will be pretty obvious in these plots, because you'll see the motor outputs railing.  To fix this, you can put shims underneath the motors to tilt the motors just a little bit in the direction of yaw for that motor.\n\n\nRC trim (Feed-Forward Torque Calculation)\n\u00b6\n\n\nIn the vast majority of cases, your multirotor will not be built perfectly.  The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different.  One way to fix this is by adding an integrator.  Integrators get rid of static offsets like what we are talking about. However, as mentioned above, integrators also always slow your response. In our case, since this offset is going to be constant, we can instead find some \"feed-forward\" or equilibrium offset torque that you need to apply to hover exactly.\n\n\nUse the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level.  This is done by trimming the aircraft with the RC trims.  These are usually the little switches next to sticks on your transmitter.  Adjust these until you can hover the multirotor without touching the sticks.\n\n\nNext, land the multirotor, disarm, center the sticks and perform a trim calibration with \nrosservice call /calibrate_rc_trim\n.  ROSflight then uses the trim settings on your transmitter to find these equilibrium or feed-forward torques that need to be applied post-controller to keep the multirotor level.  These torques will be applied to all future commands (both from the onboard computer and RC), so you will need to zero out your transmitter trims after calibration.\n\n\nEstimator Tuning\n\u00b6\n\n\nROSflight uses a non-linear complementary filter, based on the quaternion implementation of \"\nNon-linear complementary filters on the special orthogonal group\n \" by Robert Mahony\n1\n  to estimate attitude and angular rates.  The implementation has been improved with suggestions from \"\nAttitude Representation and Kinematic Propagation for Low-Cost UAVs\n\" by Robert Casey\n2\n.  A write-up of the derivation and implementation details can be found in the LaTeX report in \nreports/estimator.tex\n (You'll need to be able to compile LaTeX sources to view the PDF).\n\n\nIn addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations.  A block diagram of the estimator is shown below for reference.  \ny_{gyro}\ny_{gyro}\n and \ny_{acc}\ny_{acc}\n are gyro and accelerometer measurements, respectively and \n\\beta_{gyro}\n\\beta_{gyro}\n is the estimated gyro biases.\n\n\n\n\nTuning the Low-Pass Filter Gains\n\u00b6\n\n\nThe \nACC_LPF_ALPHA\n and \nGYRO_LPF_ALPHA\n parameters are used in the following low-pass-filter implementation. (see lines \n98-106\n of \nestimator.c\n).\n\n\n\n\nx_t = (1-\\alpha)y_t + \\alpha x_{t-1}\n\n\nx_t = (1-\\alpha)y_t + \\alpha x_{t-1}\n\n\n\n\nwhere \ny_t\ny_t\n is the measurement and \nx_t\nx_t\n is the filtered value.  Lowering \n\\alpha\n\\alpha\n will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing \n\\alpha\n\\alpha\n.  Reducing \n\\alpha\n\\alpha\n too far, however will result in a lot of noise from the sensors making its way into the motors.  This can cause motors to get really hot, so make sure you check that if you are changing the low-pass filter constants.\n\n\nTuning the Complementary Filter\n\u00b6\n\n\nThe complementary filter has two gains, \nk_p\nk_p\n and \nk_i\nk_i\n.  For a complete understanding of how these work, I would recommend reading the Mahony Paper, or the technical report in the reports folder.  In short, \nk_p\nk_p\n can be thought of the strength of accelerometer measurements in the filter, and the \nk_i\nk_i\n gain is the integral constant on the gyro bias.  These values should probably not be changed.  Before you go changing these values, make sure you \ncompletely\n understand how they work in the filter.\n\n\nIf you do decide to change these values, you should stick to the following rule of thumb.\n\n\n\n\nk_i \\approx \\tfrac{k_p}{10}.\n\n\nk_i \\approx \\tfrac{k_p}{10}.\n\n\n\n\n\n\n\n\n\n\n\n\nMahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.\u00a0\n\u21a9\n\n\n\n\n\n\nCasey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.\u00a0\n\u21a9",
            "title": "Improving performance"
        },
        {
            "location": "/user-guide/performance/#improving-performance",
            "text": "ROSflight supplies several methods to improve the performance of your aircraft.  Tuning gains, adding feed-forward torques and tuning the estimator are three ways to get your aircraft flying great!",
            "title": "Improving Performance"
        },
        {
            "location": "/user-guide/performance/#gain-tuning",
            "text": "Because there are a wide variety of multirotors out there, no one set of PID controller gains will work for all vehicles.  The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases, however, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably.  There are some great tutorials online on multirotor gain tuning, this is another tried-and-true method used to great effect at BYU.  If you are unfamiliar with PIDs, then you should probably go read about them before trying to tune a multirotor.  Getting an understanding for what is going on will definitely guide your decision making process as you try to figure out better gains.  While tuning controller gains, there is a very likely scenario that the multirotor will oscillate out of control.  To handle that, I generally add what I call \"training wheels\" to the multirotors I'm tuning, which amounts to thin carbon rods in the shape of an X zip-tied to the landing gear.  This widens out the base of the quadcopter so if you come down on a hard oscillation, chances are you'll end up upright, hopefully without a prop strike.  Here is a video of the maiden flight of ROSflight with \"training wheels\" attached.   Now, for the procedure on tuning.",
            "title": "Gain Tuning"
        },
        {
            "location": "/user-guide/performance/#tuning-roll-and-pitch",
            "text": "Here is a flowchart describing my PID tuning process for roll and pitch:   You may want to do another D-tuning iteration, and sometimes it is helpful to do a little tweaking to eek out a little performance from the differences in roll and pitch dynamics.  Notice, I didn't include any I tuning.  As a general rule, try to keep the I gain as low as possible.  It will  always  slow your reponse rate to input, and it can induce low frequency oscillations.  You should  only  have I gain on roll and pitch if one of the following is true:   You expect your CG to change or  you expect your rotor geometry to change.   Both of these are pretty rare.  Instead, use your RC transmitter to trim the aircraft so it hovers on no stick input.  In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on roll, pitch and yawrate.",
            "title": "Tuning Roll and Pitch"
        },
        {
            "location": "/user-guide/performance/#tuning-yawrate",
            "text": "Dynamically and algorithmically speaking, there is really not much advantage to using a D gain in yawrate.  Controlling with derivative requires differentiating gyro input, which tends to be pretty noisy.  In our experience, putting D in rate controllers on multirotors has always decreased performance.  Tuning Yawrate is generally pretty easy, basically, keep cranking it up until you feel like it's \"locked in\".  Sometimes a little bit of I (on the order of 0.1P) can help with this as well.  The problem with too much P on yawrate generally manifests itself in motor saturation.  Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat.  After you're done tuning, you might want to look at a plot of motor outputs during a fairly agressive flight.  Underactuated yaw will be pretty obvious in these plots, because you'll see the motor outputs railing.  To fix this, you can put shims underneath the motors to tilt the motors just a little bit in the direction of yaw for that motor.",
            "title": "Tuning Yawrate"
        },
        {
            "location": "/user-guide/performance/#rc-trim-feed-forward-torque-calculation",
            "text": "In the vast majority of cases, your multirotor will not be built perfectly.  The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different.  One way to fix this is by adding an integrator.  Integrators get rid of static offsets like what we are talking about. However, as mentioned above, integrators also always slow your response. In our case, since this offset is going to be constant, we can instead find some \"feed-forward\" or equilibrium offset torque that you need to apply to hover exactly.  Use the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level.  This is done by trimming the aircraft with the RC trims.  These are usually the little switches next to sticks on your transmitter.  Adjust these until you can hover the multirotor without touching the sticks.  Next, land the multirotor, disarm, center the sticks and perform a trim calibration with  rosservice call /calibrate_rc_trim .  ROSflight then uses the trim settings on your transmitter to find these equilibrium or feed-forward torques that need to be applied post-controller to keep the multirotor level.  These torques will be applied to all future commands (both from the onboard computer and RC), so you will need to zero out your transmitter trims after calibration.",
            "title": "RC trim (Feed-Forward Torque Calculation)"
        },
        {
            "location": "/user-guide/performance/#estimator-tuning",
            "text": "ROSflight uses a non-linear complementary filter, based on the quaternion implementation of \" Non-linear complementary filters on the special orthogonal group  \" by Robert Mahony 1   to estimate attitude and angular rates.  The implementation has been improved with suggestions from \" Attitude Representation and Kinematic Propagation for Low-Cost UAVs \" by Robert Casey 2 .  A write-up of the derivation and implementation details can be found in the LaTeX report in  reports/estimator.tex  (You'll need to be able to compile LaTeX sources to view the PDF).  In addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations.  A block diagram of the estimator is shown below for reference.   y_{gyro} y_{gyro}  and  y_{acc} y_{acc}  are gyro and accelerometer measurements, respectively and  \\beta_{gyro} \\beta_{gyro}  is the estimated gyro biases.",
            "title": "Estimator Tuning"
        },
        {
            "location": "/user-guide/performance/#tuning-the-low-pass-filter-gains",
            "text": "The  ACC_LPF_ALPHA  and  GYRO_LPF_ALPHA  parameters are used in the following low-pass-filter implementation. (see lines  98-106  of  estimator.c ).   x_t = (1-\\alpha)y_t + \\alpha x_{t-1}  x_t = (1-\\alpha)y_t + \\alpha x_{t-1}   where  y_t y_t  is the measurement and  x_t x_t  is the filtered value.  Lowering  \\alpha \\alpha  will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing  \\alpha \\alpha .  Reducing  \\alpha \\alpha  too far, however will result in a lot of noise from the sensors making its way into the motors.  This can cause motors to get really hot, so make sure you check that if you are changing the low-pass filter constants.",
            "title": "Tuning the Low-Pass Filter Gains"
        },
        {
            "location": "/user-guide/performance/#tuning-the-complementary-filter",
            "text": "The complementary filter has two gains,  k_p k_p  and  k_i k_i .  For a complete understanding of how these work, I would recommend reading the Mahony Paper, or the technical report in the reports folder.  In short,  k_p k_p  can be thought of the strength of accelerometer measurements in the filter, and the  k_i k_i  gain is the integral constant on the gyro bias.  These values should probably not be changed.  Before you go changing these values, make sure you  completely  understand how they work in the filter.  If you do decide to change these values, you should stick to the following rule of thumb.   k_i \\approx \\tfrac{k_p}{10}.  k_i \\approx \\tfrac{k_p}{10}.       Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.\u00a0 \u21a9    Casey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.\u00a0 \u21a9",
            "title": "Tuning the Complementary Filter"
        },
        {
            "location": "/user-guide/gazebo_simulation/",
            "text": "Running Simulations in Gazebo\n\u00b6\n\n\nOne useful tool that comes with rosflight is the ability to perform software-in-the-loop (SIL) simulations of the ROSflight firmware in gazebo.\n\n\nArchitecture of the SIL simulation\n\u00b6\n\n\nTo best mimic the hardware experience of ROSflight, the SIL plugin for gazebo actually implements the firmware source code as a library.  We just implemented a different \"board layer\" which instead uses gazebo instead of hardware calls for things like \"read_imu\" and \"pwm_write\".  Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between \nrosflight_io\n and the firmware.  This means the interface to the SIL plugin is identical to that of hardware.  \nrosflight_io\n is the main gateway to the firmware in simulation, just as it is in hardware.\n\n\nHere is an illustration comparing all the connections in hardware and RC.\n\n\n\nQuick Start Guide To SIL Simulation\n\u00b6\n\n\n\n\n\n\ncreate a catkin workspace\n\n\n\n\n\n\nclone the \nrosflight\n metapackage repository from \ngithub\n into your workspace\n\n\n\n\n\n\nclone submodules of the \nrosflight\n metapackage (\ngit submodule update --init --recursive\n)\n\n\n\n\n\n\nclone the \nrosflight_joy\n metapackage repository from \ngithub\n into your workspace\n\n\n\n\n\n\ninstall pygame \nsudo pip install pygame\n\n\n\n\n\n\nPerform a \ncatkin_make\n\n\n\n\n\n\nroslaunch rosflight_sim multirotor.launch\n - This will open up a gazebo simulation, and you should have the following \nrqt_graph\n\n\n\n\n\n\n\n\n\n\nAt this point, you can't actually do anything, because there is no RC connection and no \nrosflight_io\n to talk to the firmware.  Let's start by running a \nrosflight_io\n node.  In a separate terminal, run \nrosrun rosflight rosflight_io _udp:=true\n.\n\n\nThe \nudp\n parameter tells \nrosflight_io\n to simulate a serial connection over UDP rather than using the USB connection to hardware\nYour \nrqt_graph\n should look something like the following image. This looks funny, because ROS doesn't actually know that there is a UDP connection between \nrosflight_io\n and gazebo.  There is one, though, you can test it by echoing any of the topics published by \nrosflight_io\n.\n\n\n\n\n\n\n\n\n\n\n\n\nSpin up a simulated RC connection.   The easiest way to do this is with the helper package \nrosflight_joy\n.  Connect a joystick to the computer (or Taranis transmitter) and run \nrosrun rosflight_joy rc_joy RC:=/multirotor/RC\n.  This simulates the RC connection in hardware.  If everything is mapped right, you should now be able to arm, disarm and fly the aircraft in simulation!\n\n\n\n\n\n\nNote\n\n\nit is much easier to fly with a real transmitter than with an xbox-type controller.  FrSky Taranis and Realflight transmitters and interlinks are also supported.  Non-Xbox joysticks may have incorrect mappings.  If your joystick doesn't work and you write your own mapping, please contribute back your new joystick mapping!\n\n\n\n\nRemember, the SIL tries its best to replicate hardware.  That means you have to calibrate and set parameters in the same way you do in hardware.  See the hardware setup and parameter configuration pages in this documentation to see how to perform all preflight configuration before the aircraft will arm.\n\n\nAs a quick help, here is a roslaunch file which quickly does all the above \nrosrun\n steps automatically:\n\n\n<launch>\n\n  \n<arg\n \nname=\n\"mav_name\"\n            \nvalue=\n\"multirotor\"\n/>\n\n\n  \n<arg\n \nname=\n\"color\"\n               \ndefault=\n\"White\"\n/>\n\n  \n<arg\n \nname=\n\"x\"\n                   \ndefault=\n\"0\"\n/>\n\n  \n<arg\n \nname=\n\"y\"\n                   \ndefault=\n\"0\"\n/>\n\n  \n<arg\n \nname=\n\"z\"\n                   \ndefault=\n\"0.2\"\n/>\n\n  \n<arg\n \nname=\n\"yaw\"\n                 \ndefault=\n\"0\"\n/>\n\n  \n<arg\n \nname=\n\"paused\"\n              \ndefault=\n\"false\"\n/>\n\n  \n<arg\n \nname=\n\"gui\"\n                 \ndefault=\n\"true\"\n/>\n\n  \n<arg\n \nname=\n\"verbose\"\n             \ndefault=\n\"false\"\n/>\n\n  \n<arg\n \nname=\n\"debug\"\n               \ndefault=\n\"false\"\n/>\n\n\n  \n<include\n \nfile=\n\"$(find rosflight_sim)/launch/base.launch\"\n>\n\n    \n<arg\n \nname=\n\"mav_name\"\n \nvalue=\n\"$(arg mav_name)\"\n/>\n\n    \n<arg\n \nname=\n\"color\"\n \nvalue=\n\"$(arg color)\"\n/>\n\n    \n<arg\n \nname=\n\"x\"\n \nvalue=\n\"$(arg x)\"\n/>\n\n    \n<arg\n \nname=\n\"y\"\n \nvalue=\n\"$(arg y)\"\n/>\n\n    \n<arg\n \nname=\n\"z\"\n \nvalue=\n\"$(arg z)\"\n/>\n\n    \n<arg\n \nname=\n\"yaw\"\n \nvalue=\n\"$(arg yaw)\"\n/>\n\n    \n<arg\n \nname=\n\"paused\"\n \nvalue=\n\"$(arg paused)\"\n/>\n\n    \n<arg\n \nname=\n\"gui\"\n \nvalue=\n\"$(arg gui)\"\n/>\n\n    \n<arg\n \nname=\n\"verbose\"\n \nvalue=\n\"$(arg verbose)\"\n/>\n\n    \n<arg\n \nname=\n\"debug\"\n \nvalue=\n\"$(arg debug)\"\n/>\n\n    \n<arg\n \nname=\n\"xacro_file\"\n \nvalue=\n\"$(find rosflight_sim)/xacro/multirotor.urdf.xacro\"\n/>\n\n    \n<arg\n \nname=\n\"param_file\"\n \nvalue=\n\"$(find rosflight_sim)/params/multirotor.yaml\"\n/>\n\n  \n</include>\n\n\n  \n<node\n \nname=\n\"rosflight_io\"\n \npkg=\n\"rosflight\"\n \ntype=\n\"rosflight_io\"\n \noutput=\n\"screen\"\n>\n\n    \n<param\n \nname=\n\"udp\"\n \nvalue=\n\"true\"\n/>\n\n  \n</node>\n\n\n  \n<node\n \nname=\n\"rc_joy\"\n \npkg=\n\"rosflight_joy\"\n \ntype=\n\"rc_joy\"\n>\n\n    \n<remap\n \nfrom=\n\"RC\"\n \nto=\n\"multirotor/RC\"\n/>\n\n  \n</node>\n\n\n\n</launch>\n\n\n\n\n\nTo simulate a fixedwing mav, just change all instances of \nmultirotor\n in the above steps to \nfixedwing\n.",
            "title": "Running Gazebo Simulation"
        },
        {
            "location": "/user-guide/gazebo_simulation/#running-simulations-in-gazebo",
            "text": "One useful tool that comes with rosflight is the ability to perform software-in-the-loop (SIL) simulations of the ROSflight firmware in gazebo.",
            "title": "Running Simulations in Gazebo"
        },
        {
            "location": "/user-guide/gazebo_simulation/#architecture-of-the-sil-simulation",
            "text": "To best mimic the hardware experience of ROSflight, the SIL plugin for gazebo actually implements the firmware source code as a library.  We just implemented a different \"board layer\" which instead uses gazebo instead of hardware calls for things like \"read_imu\" and \"pwm_write\".  Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between  rosflight_io  and the firmware.  This means the interface to the SIL plugin is identical to that of hardware.   rosflight_io  is the main gateway to the firmware in simulation, just as it is in hardware.  Here is an illustration comparing all the connections in hardware and RC.",
            "title": "Architecture of the SIL simulation"
        },
        {
            "location": "/user-guide/gazebo_simulation/#quick-start-guide-to-sil-simulation",
            "text": "create a catkin workspace    clone the  rosflight  metapackage repository from  github  into your workspace    clone submodules of the  rosflight  metapackage ( git submodule update --init --recursive )    clone the  rosflight_joy  metapackage repository from  github  into your workspace    install pygame  sudo pip install pygame    Perform a  catkin_make    roslaunch rosflight_sim multirotor.launch  - This will open up a gazebo simulation, and you should have the following  rqt_graph      At this point, you can't actually do anything, because there is no RC connection and no  rosflight_io  to talk to the firmware.  Let's start by running a  rosflight_io  node.  In a separate terminal, run  rosrun rosflight rosflight_io _udp:=true .  The  udp  parameter tells  rosflight_io  to simulate a serial connection over UDP rather than using the USB connection to hardware\nYour  rqt_graph  should look something like the following image. This looks funny, because ROS doesn't actually know that there is a UDP connection between  rosflight_io  and gazebo.  There is one, though, you can test it by echoing any of the topics published by  rosflight_io .       Spin up a simulated RC connection.   The easiest way to do this is with the helper package  rosflight_joy .  Connect a joystick to the computer (or Taranis transmitter) and run  rosrun rosflight_joy rc_joy RC:=/multirotor/RC .  This simulates the RC connection in hardware.  If everything is mapped right, you should now be able to arm, disarm and fly the aircraft in simulation!    Note  it is much easier to fly with a real transmitter than with an xbox-type controller.  FrSky Taranis and Realflight transmitters and interlinks are also supported.  Non-Xbox joysticks may have incorrect mappings.  If your joystick doesn't work and you write your own mapping, please contribute back your new joystick mapping!   Remember, the SIL tries its best to replicate hardware.  That means you have to calibrate and set parameters in the same way you do in hardware.  See the hardware setup and parameter configuration pages in this documentation to see how to perform all preflight configuration before the aircraft will arm.  As a quick help, here is a roslaunch file which quickly does all the above  rosrun  steps automatically:  <launch> \n   <arg   name= \"mav_name\"              value= \"multirotor\" /> \n\n   <arg   name= \"color\"                 default= \"White\" /> \n   <arg   name= \"x\"                     default= \"0\" /> \n   <arg   name= \"y\"                     default= \"0\" /> \n   <arg   name= \"z\"                     default= \"0.2\" /> \n   <arg   name= \"yaw\"                   default= \"0\" /> \n   <arg   name= \"paused\"                default= \"false\" /> \n   <arg   name= \"gui\"                   default= \"true\" /> \n   <arg   name= \"verbose\"               default= \"false\" /> \n   <arg   name= \"debug\"                 default= \"false\" /> \n\n   <include   file= \"$(find rosflight_sim)/launch/base.launch\" > \n     <arg   name= \"mav_name\"   value= \"$(arg mav_name)\" /> \n     <arg   name= \"color\"   value= \"$(arg color)\" /> \n     <arg   name= \"x\"   value= \"$(arg x)\" /> \n     <arg   name= \"y\"   value= \"$(arg y)\" /> \n     <arg   name= \"z\"   value= \"$(arg z)\" /> \n     <arg   name= \"yaw\"   value= \"$(arg yaw)\" /> \n     <arg   name= \"paused\"   value= \"$(arg paused)\" /> \n     <arg   name= \"gui\"   value= \"$(arg gui)\" /> \n     <arg   name= \"verbose\"   value= \"$(arg verbose)\" /> \n     <arg   name= \"debug\"   value= \"$(arg debug)\" /> \n     <arg   name= \"xacro_file\"   value= \"$(find rosflight_sim)/xacro/multirotor.urdf.xacro\" /> \n     <arg   name= \"param_file\"   value= \"$(find rosflight_sim)/params/multirotor.yaml\" /> \n   </include> \n\n   <node   name= \"rosflight_io\"   pkg= \"rosflight\"   type= \"rosflight_io\"   output= \"screen\" > \n     <param   name= \"udp\"   value= \"true\" /> \n   </node> \n\n   <node   name= \"rc_joy\"   pkg= \"rosflight_joy\"   type= \"rc_joy\" > \n     <remap   from= \"RC\"   to= \"multirotor/RC\" /> \n   </node>  </launch>   To simulate a fixedwing mav, just change all instances of  multirotor  in the above steps to  fixedwing .",
            "title": "Quick Start Guide To SIL Simulation"
        },
        {
            "location": "/user-guide/autonomous-flight/",
            "text": "Autonomous flight\n\u00b6\n\n\nOne of the core functionalities of the ROSflight autopilot is to allow the onboard computer to send control setpoints to the embedded flight controller. These setpoints would typically be computed by a controller running as a ROS node, normally on the onboard computer.\n\n\nProvide control from an onboard computer\n\u00b6\n\n\nControl setpoints are sent to the autopilot by publishing to the \n/command\n topic that is advertised by the \nrosflight_io\n node. This topic accepts message of type \nrosflight_msgs/Command\n, which have the following structure:\n\n\nstd_msgs/Header header\nuint8 mode\nuint8 ignore\nfloat32 x\nfloat32 y\nfloat32 z\nfloat32 F\n\n\n\n\nThe \nheader\n field is a standard ROS message header. The \nx\n, \ny\n, \nz\n, and \nF\n fields are the control setpoint values, which are interpreted according to the \nmode\n and \nignore\n fields.\n\n\nThe following table describes the different values that the \nmode\n field can take, as well as how the setpoint values are interpreted for each of these modes:\n\n\n\n\n\n\n\n\nValue\n\n\nEnum\n\n\nx\n\n\ny\n\n\nz\n\n\nF\n\n\n\n\n\n\n\n\n\n\n0\n\n\nMODE_PASS_THROUGH\n\n\naileron deflection (-1 to 1)\n\n\nelevator deflection (-1 to 1)\n\n\nrudder deflection (-1 to 1)\n\n\nthrottle (0 to 1)\n\n\n\n\n\n\n1\n\n\nMODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE\n\n\nroll rate (rad/s)\n\n\npitch rate (rad/s)\n\n\nyaw rate (rad/s)\n\n\nthrottle (0 to 1)\n\n\n\n\n\n\n2\n\n\nMODE_ROLL_PITCH_YAWRATE_THROTTLE\n\n\nroll angle (rad)\n\n\npitch angle (rad)\n\n\nyaw rate (rad/s)\n\n\nthrottle (0 to 1)\n\n\n\n\n\n\n\n\nThe \nMODE_PASS_THROUGH\n mode is used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the \nMODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE\n and \nMODE_ROLL_PITCH_YAWRATE_THROTTLE\n modes are used for multirotor vehicles to specify the attitude rates or angles respectively.\n\n\nThe \nignore\n field is used if you want to specify control setpoints for some, but not all, of the axes. For example, I may want to specify a throttle setpoint to perform altitude hold, but still let the RC pilot specify the attitude setpoints. The \nignore\n field is a bitmask that can be populated by combining the following values:\n\n\n\n\n\n\n\n\nValue\n\n\nEnum\n\n\nResult\n\n\n\n\n\n\n\n\n\n\n0\n\n\nIGNORE_NONE\n\n\nIgnore none of the fields (default)\n\n\n\n\n\n\n1\n\n\nIGNORE_X\n\n\nIgnore the \nx\n field\n\n\n\n\n\n\n2\n\n\nIGNORE_Y\n\n\nIgnore the \ny\n field\n\n\n\n\n\n\n4\n\n\nIGNORE_Z\n\n\nIgnore the \nz\n field\n\n\n\n\n\n\n8\n\n\nIGNORE_F\n\n\nIgnore the \nF\n field\n\n\n\n\n\n\n\n\nFor the previous example, I would set the \nignore\n field to a value of\n\nignore = IGNORE_X | IGNORE_Y | IGNORE_Z\n\n\n\nThe best practice is to use enum names rather than the actual numeric values for the \nmode\n and \nignore\n fields. For example, to specify a multirotor attitude angle command in C++ I might have\n\n#include\n \n<ros/ros.h>\n\n\n#include\n \n<rosflight_msgs/Command.h>\n\n\n\nrosflight_msgs\n::\nCommand\n \nmsg\n;\n\n\nmsg\n.\nheader\n.\nstamp\n \n=\n \nros\n::\nTime\n::\nnow\n();\n\n\nmsg\n.\nmode\n \n=\n \nrosflight_msgs\n::\nCommand\n::\nMODE_ROLL_PITCH_YAWRATE_THROTTLE\n;\n\n\nmsg\n.\nignore\n \n=\n \nrosflight_msgs\n::\nCommand\n::\nIGNORE_NONE\n;\n\n\nmsg\n.\nx\n \n=\n \n0.0\n;\n\n\nmsg\n.\ny\n \n=\n \n0.0\n;\n\n\nmsg\n.\nz\n \n=\n \n0.0\n;\n\n\nmsg\n.\nF\n \n=\n \n0.6\n;\n\n\n\nand in Python I might have\n\nimport\n \nrospy\n\n\nfrom\n \nrosflight_msgs.msg\n \nimport\n \nCommand\n\n\n\nmsg\n \n=\n \nCommand\n()\n\n\nmsg\n.\nheader\n.\nstamp\n \n=\n \nrospy\n.\nTime\n.\nnow\n()\n\n\nmsg\n.\nmode\n \n=\n \nCommand\n.\nMODE_ROLL_PITCH_YAWRATE_THROTTLE\n\n\nmsg\n.\nignore\n \n=\n \nCommand\n.\nIGNORE_NONE\n\n\nmsg\n.\nx\n \n=\n \n0.0\n\n\nmsg\n.\ny\n \n=\n \n0.0\n\n\nmsg\n.\nz\n \n=\n \n0.0\n\n\nmsg\n.\nF\n \n=\n \n0.6\n\n\n\nI would then publish this message to the \n/command\n topic to forward it to the embedded flight controller.\n\n\nFly waypoints with ros_plane or ros_copter\n\u00b6\n\n\nWaypoint following is not supported natively by the ROSflight stack. However, the \nROSplane\n and \nROScopter\n projects are good example implementations of how to achieve this using ROSflight. They also provide good examples of how you might go about integrating your own guidance or control algorithms with the ROSflight stack.",
            "title": "Autonomous flight"
        },
        {
            "location": "/user-guide/autonomous-flight/#autonomous-flight",
            "text": "One of the core functionalities of the ROSflight autopilot is to allow the onboard computer to send control setpoints to the embedded flight controller. These setpoints would typically be computed by a controller running as a ROS node, normally on the onboard computer.",
            "title": "Autonomous flight"
        },
        {
            "location": "/user-guide/autonomous-flight/#provide-control-from-an-onboard-computer",
            "text": "Control setpoints are sent to the autopilot by publishing to the  /command  topic that is advertised by the  rosflight_io  node. This topic accepts message of type  rosflight_msgs/Command , which have the following structure:  std_msgs/Header header\nuint8 mode\nuint8 ignore\nfloat32 x\nfloat32 y\nfloat32 z\nfloat32 F  The  header  field is a standard ROS message header. The  x ,  y ,  z , and  F  fields are the control setpoint values, which are interpreted according to the  mode  and  ignore  fields.  The following table describes the different values that the  mode  field can take, as well as how the setpoint values are interpreted for each of these modes:     Value  Enum  x  y  z  F      0  MODE_PASS_THROUGH  aileron deflection (-1 to 1)  elevator deflection (-1 to 1)  rudder deflection (-1 to 1)  throttle (0 to 1)    1  MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE  roll rate (rad/s)  pitch rate (rad/s)  yaw rate (rad/s)  throttle (0 to 1)    2  MODE_ROLL_PITCH_YAWRATE_THROTTLE  roll angle (rad)  pitch angle (rad)  yaw rate (rad/s)  throttle (0 to 1)     The  MODE_PASS_THROUGH  mode is used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the  MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE  and  MODE_ROLL_PITCH_YAWRATE_THROTTLE  modes are used for multirotor vehicles to specify the attitude rates or angles respectively.  The  ignore  field is used if you want to specify control setpoints for some, but not all, of the axes. For example, I may want to specify a throttle setpoint to perform altitude hold, but still let the RC pilot specify the attitude setpoints. The  ignore  field is a bitmask that can be populated by combining the following values:     Value  Enum  Result      0  IGNORE_NONE  Ignore none of the fields (default)    1  IGNORE_X  Ignore the  x  field    2  IGNORE_Y  Ignore the  y  field    4  IGNORE_Z  Ignore the  z  field    8  IGNORE_F  Ignore the  F  field     For the previous example, I would set the  ignore  field to a value of ignore = IGNORE_X | IGNORE_Y | IGNORE_Z  The best practice is to use enum names rather than the actual numeric values for the  mode  and  ignore  fields. For example, to specify a multirotor attitude angle command in C++ I might have #include   <ros/ros.h>  #include   <rosflight_msgs/Command.h>  rosflight_msgs :: Command   msg ;  msg . header . stamp   =   ros :: Time :: now ();  msg . mode   =   rosflight_msgs :: Command :: MODE_ROLL_PITCH_YAWRATE_THROTTLE ;  msg . ignore   =   rosflight_msgs :: Command :: IGNORE_NONE ;  msg . x   =   0.0 ;  msg . y   =   0.0 ;  msg . z   =   0.0 ;  msg . F   =   0.6 ;  \nand in Python I might have import   rospy  from   rosflight_msgs.msg   import   Command  msg   =   Command ()  msg . header . stamp   =   rospy . Time . now ()  msg . mode   =   Command . MODE_ROLL_PITCH_YAWRATE_THROTTLE  msg . ignore   =   Command . IGNORE_NONE  msg . x   =   0.0  msg . y   =   0.0  msg . z   =   0.0  msg . F   =   0.6  \nI would then publish this message to the  /command  topic to forward it to the embedded flight controller.",
            "title": "Provide control from an onboard computer"
        },
        {
            "location": "/user-guide/autonomous-flight/#fly-waypoints-with-ros_plane-or-ros_copter",
            "text": "Waypoint following is not supported natively by the ROSflight stack. However, the  ROSplane  and  ROScopter  projects are good example implementations of how to achieve this using ROSflight. They also provide good examples of how you might go about integrating your own guidance or control algorithms with the ROSflight stack.",
            "title": "Fly waypoints with ros_plane or ros_copter"
        },
        {
            "location": "/developer-guide/contribution-guidelines/",
            "text": "Contributing To the Firmware\n\u00b6\n\n\nPer our vision stated in the \nintroduction\n, ROSflight is intended to be a streamlined, bare-bones autopilot.  We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the firmware.  We hope that the firmware is useful, but in an attempt to avoid \"feature creep\" we will be very discriminatory in merging pull requests whose purpose is to simply add features.  Forking the repository in order to add features is totally acceptable and encouraged, just stay in contact with us and recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license).\n\n\nIn addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like.  We will likely be nit-picky and perhaps a little harsh about this in pull requests.  Please do not be offended.  By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature.\n\n\nPull requests are also required to pass the automated unit tests. You can test your changes against these unit tests before pushing by executing the \nrun_tests.sh\n script in the root directory of the firmware repo.\n\n\nAlthough we strive for complete in-code documentation, in practice this often gets left behind for the sake of rapid development.  If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the \nGitHub issues page\n or \nforum\n, and pull requests which improve documentation.  Several new developers have started with first improving documentation to get a handle on how things work.\n\n\nCommunication\n\u00b6\n\n\nThere are two channels to communicate with the developer team.  For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate \nfirmware\n or \nROS stack\n GitHub issue page.  For questions and other discussions, please use the \nforum\n.",
            "title": "Contribution Guidelines"
        },
        {
            "location": "/developer-guide/contribution-guidelines/#contributing-to-the-firmware",
            "text": "Per our vision stated in the  introduction , ROSflight is intended to be a streamlined, bare-bones autopilot.  We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the firmware.  We hope that the firmware is useful, but in an attempt to avoid \"feature creep\" we will be very discriminatory in merging pull requests whose purpose is to simply add features.  Forking the repository in order to add features is totally acceptable and encouraged, just stay in contact with us and recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license).  In addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like.  We will likely be nit-picky and perhaps a little harsh about this in pull requests.  Please do not be offended.  By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature.  Pull requests are also required to pass the automated unit tests. You can test your changes against these unit tests before pushing by executing the  run_tests.sh  script in the root directory of the firmware repo.  Although we strive for complete in-code documentation, in practice this often gets left behind for the sake of rapid development.  If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the  GitHub issues page  or  forum , and pull requests which improve documentation.  Several new developers have started with first improving documentation to get a handle on how things work.",
            "title": "Contributing To the Firmware"
        },
        {
            "location": "/developer-guide/contribution-guidelines/#communication",
            "text": "There are two channels to communicate with the developer team.  For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate  firmware  or  ROS stack  GitHub issue page.  For questions and other discussions, please use the  forum .",
            "title": "Communication"
        },
        {
            "location": "/developer-guide/style-guide/",
            "text": "Style Guide\n\u00b6\n\n\nAny contributions to the firmware should adhere to the following style guidelines\n\n\nWhite space and Line Endings\n\u00b6\n\n\nPlease try not to commit anything that only changes white space or line endings. To check if that's going to happen, run \ngit diff --check\n before you stage your files. Git will warn you about obnoxious changes. Please fix them.\n\n\nCode Style\n\u00b6\n\n\nThe following ROSflight code style is based on the \nROS C++ style guide\n.\nROSflight uses the C++11 standard.\n\n\nIndentation\n\u00b6\n\n\nIndentation should be \n2 spaces\n (no tabs). Case statements in switch blocks should not be indented, e.g.\n\n\nswitch\n \n(\nvariable\n)\n\n\n{\n\n\ncase\n \n1\n:\n\n  \n// do something\n\n  \nbreak\n;\n\n\ndefault\n:\n\n  \nbreak\n;\n\n\n}\n\n\n\n\n\nBraces\n\u00b6\n\n\nBraces should be placed on the next line, e.g.\n\n\nif\n \n(\ni\n \n>\n \n2\n)\n\n\n{\n\n  \n// do stuff\n\n\n}\n\n\nelse\n\n\n{\n\n  \n// do something else\n\n\n}\n\n\n\n\n\nFor a conditional with only one statement, the braces can be omitted but the statement should be indented:\n\n\nif\n \n(\ni\n \n>\n \n2\n)\n\n  \nx\n \n=\n \n3\n;\n\n\n\n\n\nSpaces\n\u00b6\n\n\nThere should be a space between \nif\n, \nfor\n, or \nwhile\n and the condition, e.g. \nwhile (true)\n, not \nwhile(true)\n.\n\n\nNaming Conventions\n\u00b6\n\n\n\n\nClass names should be capitalized with no spaces (i.e. \nStateManager\n).\n\n\nMember variables should contain a post-pended underscore (i.e. \ndata_\n).\n\n\nMember functions should be all lower case with underscores (i.e. \nset_error()\n).\n\n\nInteger types should be defined using the \ncstdint\n convention (i.e. \nuint8_t\n, \nint64_t\n, \nfloat\n ...).\n\n\nBoolean values should be assigned \ntrue\n or \nfalse\n, not \n0\n and \n1\n.\n\n\n\n\nFunction Arguments\n\u00b6\n\n\nPrimitive data types (\nint\n, \nfloat\n, etc.) should always be passed by value. Other types (e.g. classes) should be passed by reference and should maintain proper const-correctness. Arguments that are modified by the function should be passed by pointer instead of reference, to make the fact that the argument will be changed clearer in the calling code. For example:\n\n\nvoid\n \ndo_something\n(\nfloat\n \ndt\n,\n \nconst\n \nMyClass\n&\n \ndata\n,\n \nint\n*\n \noutput\n);\n\n\n\n\n\nThis function would be called as\n\n\nfloat\n \ndt\n \n=\n \n0.01f\n;\n\n\nMyClass\n \nmy_class\n;\n\n\nint\n \nvalue\n;\n\n\n\ndo_something\n(\ndt\n,\n \nmy_class\n,\n \n&\nvalue\n);\n\n\n\n\n\nThis makes it clear the \nvalue\n is modified by the function call.\n\n\nClasses\n\u00b6\n\n\nAll modules should be defined as a self-contained class.  All member variables should be declared as \"private,\" named with a post-pended underscore  and accessed through inline accessor functions.  All accessible data should be encapsulated in a struct.  For example, here is a snippet from the \nSensors\n module in the firmware:\n\n\nclass\n \nSensors\n\n\n{\n\n\npublic\n:\n\n  \nstruct\n \nData\n\n  \n{\n\n    \nvector_t\n \naccel\n \n=\n \n{\n0\n,\n \n0\n,\n \n0\n};\n\n    \nvector_t\n \ngyro\n \n=\n \n{\n0\n,\n \n0\n,\n \n0\n};\n\n    \nfloat\n \nimu_temperature\n \n=\n \n0\n;\n\n    \nuint64_t\n \nimu_time\n \n=\n \n0\n;\n\n\n    \nfloat\n \ndiff_pressure_velocity\n \n=\n \n0\n;\n\n    \nfloat\n \ndiff_pressure\n \n=\n \n0\n;\n\n    \nfloat\n \ndiff_pressure_temp\n \n=\n \n0\n;\n\n    \nbool\n \ndiff_pressure_valid\n \n=\n \nfalse\n;\n\n\n    \nfloat\n \nbaro_altitude\n \n=\n \n0\n;\n\n    \nfloat\n \nbaro_pressure\n \n=\n \n0\n;\n\n    \nfloat\n \nbaro_temperature\n \n=\n \n0\n;\n\n    \nbool\n \nbaro_valid\n \n=\n \nfalse\n;\n\n\n    \nfloat\n \nsonar_range\n \n=\n \n0\n;\n\n    \nbool\n \nsonar_range_valid\n \n=\n \nfalse\n;\n\n\n    \nvector_t\n \nmag\n \n=\n \n{\n0\n,\n \n0\n,\n \n0\n};\n\n\n    \nbool\n \nbaro_present\n \n=\n \nfalse\n;\n\n    \nbool\n \nmag_present\n \n=\n \nfalse\n;\n\n    \nbool\n \nsonar_present\n \n=\n \nfalse\n;\n\n    \nbool\n \ndiff_pressure_present\n \n=\n \nfalse\n;\n\n  \n};\n\n\n  \nSensors\n(\nROSflight\n&\n \nrosflight\n);\n\n\n  \ninline\n \nconst\n \nData\n&\n \ndata\n()\n \nconst\n \n{\n \nreturn\n \ndata_\n;\n \n}\n\n\n\nprivate\n:\n\n  \nData\n \ndata_\n;\n\n\n}\n\n\n\n\n\nNote that \ndata_\n is a private member variable, but the \nData\n struct is declared publicly and \ndata_\n is accessed through in \ninline const\n accessor to prevent another module changing \ndata_\n.\n\n\nEnums\n\u00b6\n\n\nEnums should be declared using the following style:\n\nenum\n \nArmedState\n\n\n{\n\n  \nARMED_STATE_INIT\n,\n\n  \nARMED_STATE_DISARMED\n,\n\n  \nARMED_STATE_ARMED\n\n\n};\n\n\n\n\nThe name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum.\n\n\nStructs\n\u00b6\n\n\nStructs should be declared using the following style:\n\nstruct\n \nSomeValue\n\n\n{\n\n  \nint\n \nv1\n;\n\n  \nint\n \nv2\n;\n\n\n};\n\n\n\nStruct type names should be in CamelCase.\n\n\nGlobals\n\u00b6\n\n\nThe use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals).  This should only occur in board support layers and not in the core ROSflight libary code.\n\n\nInclude Order\n\u00b6\n\n\nInclude files at the top of your file in the following order:\n\n\n\n\nStandard library (e.g. \n<cstdint>\n)\n\n\nFiles from external libraries included in the project (e.g. \n<breezystm32/breezystm32.h>\n, \n<mavlink/v1.0/common/mavlink.h>\n)\n\n\nOther header files from this project (e.g. \n\"rosflight.h\"\n)\n\n\nThe header file for this specific source file\n\n\n\n\nGroup the includes according to the above list with an empty line between each group (for external libraries, you may subdivide group 2 into a group for each library). The first two groups should use angle brackets (\n<>\n), and the last two groups should use quotation marks (\n\"\"\n). Files from external libraries should be namespaced by the library name (e.g. \n<breezystm32/breezystm32.h>\n, not \n<breezystm32.h>\n).\n\n\nAlphabetize the files within each group . Don't change the include order to fix build errors; if you have to do that it means you aren't including a file somewhere that you should. Please fix it by including all the right files.\n\n\nFor example, in \nsensors.c\n I might have:\n\n#include\n \n<cstdbool>\n\n\n#include\n \n<cstdint>\n\n\n\n#include\n \n<breezystm32/breezystm32.h>\n\n\n#include\n \n<breezystm32/drv_mpu6050.h>\n\n\n\n#include\n \n\"param.h\"\n\n\n\n#include\n \n\"sensors.h\"\n\n\n\n\nNamespacing\n\u00b6\n\n\nAll modules in the firmware should be encapsulated in the \nrosflight_firmware\n namepace.  This prevents name-clashing in SIL compilation.",
            "title": "Style Guide"
        },
        {
            "location": "/developer-guide/style-guide/#style-guide",
            "text": "Any contributions to the firmware should adhere to the following style guidelines",
            "title": "Style Guide"
        },
        {
            "location": "/developer-guide/style-guide/#white-space-and-line-endings",
            "text": "Please try not to commit anything that only changes white space or line endings. To check if that's going to happen, run  git diff --check  before you stage your files. Git will warn you about obnoxious changes. Please fix them.",
            "title": "White space and Line Endings"
        },
        {
            "location": "/developer-guide/style-guide/#code-style",
            "text": "The following ROSflight code style is based on the  ROS C++ style guide .\nROSflight uses the C++11 standard.",
            "title": "Code Style"
        },
        {
            "location": "/developer-guide/style-guide/#indentation",
            "text": "Indentation should be  2 spaces  (no tabs). Case statements in switch blocks should not be indented, e.g.  switch   ( variable )  {  case   1 : \n   // do something \n   break ;  default : \n   break ;  }",
            "title": "Indentation"
        },
        {
            "location": "/developer-guide/style-guide/#braces",
            "text": "Braces should be placed on the next line, e.g.  if   ( i   >   2 )  { \n   // do stuff  }  else  { \n   // do something else  }   For a conditional with only one statement, the braces can be omitted but the statement should be indented:  if   ( i   >   2 ) \n   x   =   3 ;",
            "title": "Braces"
        },
        {
            "location": "/developer-guide/style-guide/#spaces",
            "text": "There should be a space between  if ,  for , or  while  and the condition, e.g.  while (true) , not  while(true) .",
            "title": "Spaces"
        },
        {
            "location": "/developer-guide/style-guide/#naming-conventions",
            "text": "Class names should be capitalized with no spaces (i.e.  StateManager ).  Member variables should contain a post-pended underscore (i.e.  data_ ).  Member functions should be all lower case with underscores (i.e.  set_error() ).  Integer types should be defined using the  cstdint  convention (i.e.  uint8_t ,  int64_t ,  float  ...).  Boolean values should be assigned  true  or  false , not  0  and  1 .",
            "title": "Naming Conventions"
        },
        {
            "location": "/developer-guide/style-guide/#function-arguments",
            "text": "Primitive data types ( int ,  float , etc.) should always be passed by value. Other types (e.g. classes) should be passed by reference and should maintain proper const-correctness. Arguments that are modified by the function should be passed by pointer instead of reference, to make the fact that the argument will be changed clearer in the calling code. For example:  void   do_something ( float   dt ,   const   MyClass &   data ,   int *   output );   This function would be called as  float   dt   =   0.01f ;  MyClass   my_class ;  int   value ;  do_something ( dt ,   my_class ,   & value );   This makes it clear the  value  is modified by the function call.",
            "title": "Function Arguments"
        },
        {
            "location": "/developer-guide/style-guide/#classes",
            "text": "All modules should be defined as a self-contained class.  All member variables should be declared as \"private,\" named with a post-pended underscore  and accessed through inline accessor functions.  All accessible data should be encapsulated in a struct.  For example, here is a snippet from the  Sensors  module in the firmware:  class   Sensors  {  public : \n   struct   Data \n   { \n     vector_t   accel   =   { 0 ,   0 ,   0 }; \n     vector_t   gyro   =   { 0 ,   0 ,   0 }; \n     float   imu_temperature   =   0 ; \n     uint64_t   imu_time   =   0 ; \n\n     float   diff_pressure_velocity   =   0 ; \n     float   diff_pressure   =   0 ; \n     float   diff_pressure_temp   =   0 ; \n     bool   diff_pressure_valid   =   false ; \n\n     float   baro_altitude   =   0 ; \n     float   baro_pressure   =   0 ; \n     float   baro_temperature   =   0 ; \n     bool   baro_valid   =   false ; \n\n     float   sonar_range   =   0 ; \n     bool   sonar_range_valid   =   false ; \n\n     vector_t   mag   =   { 0 ,   0 ,   0 }; \n\n     bool   baro_present   =   false ; \n     bool   mag_present   =   false ; \n     bool   sonar_present   =   false ; \n     bool   diff_pressure_present   =   false ; \n   }; \n\n   Sensors ( ROSflight &   rosflight ); \n\n   inline   const   Data &   data ()   const   {   return   data_ ;   }  private : \n   Data   data_ ;  }   Note that  data_  is a private member variable, but the  Data  struct is declared publicly and  data_  is accessed through in  inline const  accessor to prevent another module changing  data_ .",
            "title": "Classes"
        },
        {
            "location": "/developer-guide/style-guide/#enums",
            "text": "Enums should be declared using the following style: enum   ArmedState  { \n   ARMED_STATE_INIT , \n   ARMED_STATE_DISARMED , \n   ARMED_STATE_ARMED  };   The name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum.",
            "title": "Enums"
        },
        {
            "location": "/developer-guide/style-guide/#structs",
            "text": "Structs should be declared using the following style: struct   SomeValue  { \n   int   v1 ; \n   int   v2 ;  };  \nStruct type names should be in CamelCase.",
            "title": "Structs"
        },
        {
            "location": "/developer-guide/style-guide/#globals",
            "text": "The use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals).  This should only occur in board support layers and not in the core ROSflight libary code.",
            "title": "Globals"
        },
        {
            "location": "/developer-guide/style-guide/#include-order",
            "text": "Include files at the top of your file in the following order:   Standard library (e.g.  <cstdint> )  Files from external libraries included in the project (e.g.  <breezystm32/breezystm32.h> ,  <mavlink/v1.0/common/mavlink.h> )  Other header files from this project (e.g.  \"rosflight.h\" )  The header file for this specific source file   Group the includes according to the above list with an empty line between each group (for external libraries, you may subdivide group 2 into a group for each library). The first two groups should use angle brackets ( <> ), and the last two groups should use quotation marks ( \"\" ). Files from external libraries should be namespaced by the library name (e.g.  <breezystm32/breezystm32.h> , not  <breezystm32.h> ).  Alphabetize the files within each group . Don't change the include order to fix build errors; if you have to do that it means you aren't including a file somewhere that you should. Please fix it by including all the right files.  For example, in  sensors.c  I might have: #include   <cstdbool>  #include   <cstdint>  #include   <breezystm32/breezystm32.h>  #include   <breezystm32/drv_mpu6050.h>  #include   \"param.h\"  #include   \"sensors.h\"",
            "title": "Include Order"
        },
        {
            "location": "/developer-guide/style-guide/#namespacing",
            "text": "All modules in the firmware should be encapsulated in the  rosflight_firmware  namepace.  This prevents name-clashing in SIL compilation.",
            "title": "Namespacing"
        },
        {
            "location": "/developer-guide/code-architecture/",
            "text": "Code Architecture\n\u00b6\n\n\nThe firmware is divided into two main components: the \nROSflight library\n, and a collection of \nboard implementations\n.\nThis division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller (such as the Naze32 or Revo) or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the \nhardware abstraction layer\n.\nThis architecture is illustrated in the following diagram:\n\n\n\n\nROSflight Core Library\n\u00b6\n\n\nThe ROSflight library consists of all the code in the \ninclude\n and \nsrc\n directories of the firmware repository.\nThis includes the code for the what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, communication link, etc.) required for flight.\nIt also includes the interface definition for the hardware abstraction layer, which is defined by the abstract \nBoard\n class in \ninclude/board.h\n.\nExternal libraries (such as MAVLink) are contained in the \nlib\n folder.\n\n\nBoard Abstraction\n\u00b6\n\n\nThe board implementations are contained in the \nboards\n directory, with each board contained in its own subdirectory (e.g. \nboards/naze\n).\nEach board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack.\nThe Revo implementation in the \nboards/F4\n shows how this is done for an embedded flight controller.\nExamples of board implementations for SIL simulation are found in the \nrosflight_firmware\n and \nrosflight_sim\n ROS packages available \nhere\n.\n\n\nThe flight stack is encapsulated in the \nROSflight\n class defined at \ninclude/rosflight.h\n.\nThis class contains two public functions: \ninit()\n and \nrun()\n.\nIts constructor requires a single argument that is an implementation of the \nBoard\n interface.\nEach board implementation is required to provide its own \nmain()\n function that instantiates an implementation of the \nBoard\n interface, instantiates a \nROSflight\n object with that board interface as an argument, calls the \ninit()\n method of that \nROSflight\n object once, then calls the \nrun()\n method in a loop.\nFor example, here is the main function for the Naze32 board implementation (\nboard/naze/main.cpp\n):\n\n\n#include\n \n\"naze32.h\"\n\n\n#include\n \n\"rosflight.h\"\n\n\n\nint\n \nmain\n()\n\n\n{\n\n  \nrosflight_firmware\n::\nNaze32\n \nboard\n;\n\n  \nrosflight_firmware\n::\nROSflight\n \nfirmware\n(\nboard\n);\n\n\n  \nfirmware\n.\ninit\n();\n\n\n  \nwhile\n \n(\ntrue\n)\n\n  \n{\n\n    \nfirmware\n.\nrun\n();\n\n  \n}\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\nFlight stack\n\u00b6\n\n\nThe flight stack is encapsulated by the \nROSflight\n class defined in \ninclude/rosflight.h\n.\nIt consists of a collection of \nmodules\n.\nEach of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality.\nThe following diagram illustrates these modules and the data flow between them.\nRectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer:\n\n\n\n\nWe'll describe each of these modules in the following sections:\n\n\nState manager\n\u00b6\n\n\nThis module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle.\nWhile only the MAVLink data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status.\n\n\nParameter server\n\u00b6\n\n\nThis module handles all of the parameters for the flight stack.\nIt supports the getting and setting of integer and floating point parameters, and the saving of these parameters to non-volatile memory.\nSetting and getting of parameters from the onboard computer is done through the MAVLink interface.\nWhile no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server.\n\n\nMAVLink\n\u00b6\n\n\nThis module handles all serial communication between the flight controller and onboard computer.\nThis includes streaming data and receiving offboard control setpoints and other commands from the computer.\nThis module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server.\n\n\nSensors\n\u00b6\n\n\nThis module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.).\nIts responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters.\n\n\nEstimator\n\u00b6\n\n\nThis module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data.\n\n\nRC\n\u00b6\n\n\nThe RC module is responsible for interpreting the RC signals coming from the transmitter/receiver.\nThis includes mapping channels to their appropriate functions and reversing directions if necessary.\n\n\nCommand manager\n\u00b6\n\n\nThe command manager combines inputs from the RC and MAVLink modules to produce a control setpoint.\nIts main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode.\n\n\nController\n\u00b6\n\n\nThe controller uses the inputs from the command manager and estimator to compute a control output.\nThis control output is computed in a generic form (\nx\nx\n, \ny\ny\n, and \nz\nz\n torques and force \nF\nF\n), and is later converted into actual motor commands by the mixer.\n\n\nMixer\n\u00b6\n\n\nThe mixer takes the generic outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.",
            "title": "Code Architecture"
        },
        {
            "location": "/developer-guide/code-architecture/#code-architecture",
            "text": "The firmware is divided into two main components: the  ROSflight library , and a collection of  board implementations .\nThis division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller (such as the Naze32 or Revo) or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the  hardware abstraction layer .\nThis architecture is illustrated in the following diagram:",
            "title": "Code Architecture"
        },
        {
            "location": "/developer-guide/code-architecture/#rosflight-core-library",
            "text": "The ROSflight library consists of all the code in the  include  and  src  directories of the firmware repository.\nThis includes the code for the what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, communication link, etc.) required for flight.\nIt also includes the interface definition for the hardware abstraction layer, which is defined by the abstract  Board  class in  include/board.h .\nExternal libraries (such as MAVLink) are contained in the  lib  folder.",
            "title": "ROSflight Core Library"
        },
        {
            "location": "/developer-guide/code-architecture/#board-abstraction",
            "text": "The board implementations are contained in the  boards  directory, with each board contained in its own subdirectory (e.g.  boards/naze ).\nEach board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack.\nThe Revo implementation in the  boards/F4  shows how this is done for an embedded flight controller.\nExamples of board implementations for SIL simulation are found in the  rosflight_firmware  and  rosflight_sim  ROS packages available  here .  The flight stack is encapsulated in the  ROSflight  class defined at  include/rosflight.h .\nThis class contains two public functions:  init()  and  run() .\nIts constructor requires a single argument that is an implementation of the  Board  interface.\nEach board implementation is required to provide its own  main()  function that instantiates an implementation of the  Board  interface, instantiates a  ROSflight  object with that board interface as an argument, calls the  init()  method of that  ROSflight  object once, then calls the  run()  method in a loop.\nFor example, here is the main function for the Naze32 board implementation ( board/naze/main.cpp ):  #include   \"naze32.h\"  #include   \"rosflight.h\"  int   main ()  { \n   rosflight_firmware :: Naze32   board ; \n   rosflight_firmware :: ROSflight   firmware ( board ); \n\n   firmware . init (); \n\n   while   ( true ) \n   { \n     firmware . run (); \n   } \n   return   0 ;  }",
            "title": "Board Abstraction"
        },
        {
            "location": "/developer-guide/code-architecture/#flight-stack",
            "text": "The flight stack is encapsulated by the  ROSflight  class defined in  include/rosflight.h .\nIt consists of a collection of  modules .\nEach of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality.\nThe following diagram illustrates these modules and the data flow between them.\nRectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer:   We'll describe each of these modules in the following sections:",
            "title": "Flight stack"
        },
        {
            "location": "/developer-guide/code-architecture/#state-manager",
            "text": "This module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle.\nWhile only the MAVLink data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status.",
            "title": "State manager"
        },
        {
            "location": "/developer-guide/code-architecture/#parameter-server",
            "text": "This module handles all of the parameters for the flight stack.\nIt supports the getting and setting of integer and floating point parameters, and the saving of these parameters to non-volatile memory.\nSetting and getting of parameters from the onboard computer is done through the MAVLink interface.\nWhile no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server.",
            "title": "Parameter server"
        },
        {
            "location": "/developer-guide/code-architecture/#mavlink",
            "text": "This module handles all serial communication between the flight controller and onboard computer.\nThis includes streaming data and receiving offboard control setpoints and other commands from the computer.\nThis module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server.",
            "title": "MAVLink"
        },
        {
            "location": "/developer-guide/code-architecture/#sensors",
            "text": "This module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.).\nIts responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters.",
            "title": "Sensors"
        },
        {
            "location": "/developer-guide/code-architecture/#estimator",
            "text": "This module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data.",
            "title": "Estimator"
        },
        {
            "location": "/developer-guide/code-architecture/#rc",
            "text": "The RC module is responsible for interpreting the RC signals coming from the transmitter/receiver.\nThis includes mapping channels to their appropriate functions and reversing directions if necessary.",
            "title": "RC"
        },
        {
            "location": "/developer-guide/code-architecture/#command-manager",
            "text": "The command manager combines inputs from the RC and MAVLink modules to produce a control setpoint.\nIts main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode.",
            "title": "Command manager"
        },
        {
            "location": "/developer-guide/code-architecture/#controller",
            "text": "The controller uses the inputs from the command manager and estimator to compute a control output.\nThis control output is computed in a generic form ( x x ,  y y , and  z z  torques and force  F F ), and is later converted into actual motor commands by the mixer.",
            "title": "Controller"
        },
        {
            "location": "/developer-guide/code-architecture/#mixer",
            "text": "The mixer takes the generic outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.",
            "title": "Mixer"
        },
        {
            "location": "/developer-guide/building-flashing/",
            "text": "Building and Flashing the firmware\n\u00b6\n\n\nThese documents are designed to help developers get up and running with developing new features and understanding the internals of the firmware.  Development is currently supported only on Ubuntu Linux 16.04.\n\n\nBuilding firmware from source\n\u00b6\n\n\nTo build the firmware, you will need the latest version of the ARM embedded toolchain.\n\n\nsudo apt install -y lib32ncurses5\nwget https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q3-update/+download/gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2\ntar -xvf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2\nsudo mv gcc-arm-none-eabi-5_4-2016q3 /opt/.\n\necho\n \n\"export PATH=\\$PATH:/opt/gcc-arm-none-eabi-5_4-2016q3/bin\"\n >> ~/.bashrc\nrm -rf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2\n\n\n\n\nThen, simply clone the repository, pull down the submodules, and build:\n\n\ngit clone https://github.com/rosflight/firmware\n\ncd\n firmware\ngit submodule update --init --recursive\nmake\n\n\n\n\nFlashing newly built firmware (F4)\n\u00b6\n\n\nConfigure your machine to recognize the flight controller\n\u00b6\n\n\nBe sure your user is in the \ndialout\n and \nplugdev\n group so you have access to the serial ports\n\nsudo usermod -a -G plugdev <username>\nsudo usermod -a -G dialout <username>\n\n\nDisable the modem-manager (sometimes linux thinks the device is a modem)\n\nsudo systemctl stop ModemManager.service\n\n\n\n\n\nTip\n\n\ndfu-util auto-detects F4-based boards.  Try \ndfu-util\n -ls to make sure your board is in bootloader mode\n\n\n\n\nF4\n\u00b6\n\n\nInstall the dfu-util utility\n\n\nsudo apt install dfu-util\n\n\n\n\nThen put the board in bootloader mode (short the boot pins while cycling power) and type \nmake flash\n\n\nF1\n\u00b6\n\n\nInstall the stm32flash utility\n\n\ngit clone git://git.code.sf.net/p/stm32flash/code stm32flash-code\n\ncd\n stm32flash-code\nsudo make install\n\ncd\n ..\nrm -rf stm32flash-code\n\n\n\n\nBuilding and running unit tests\n\u00b6\n\n\nContributions will need to pass our continuous integration unit tests before merging.  To test your contributions against these tests, you'll first need to install Eigen and gtest\n\n\nsudo apt install libgtest-dev libeigen3-dev cmake\n\ncd\n /usr/src/gtest\nsudo cmake CMakeLists.txt\nsudo make\nsudo cp *.a /usr/lib\n\n\n\n\nThen you'll need to build and run the tests themselves\n\n\ncd\n <firmware_directory>/test\nmkdir build\n\ncd\n build\ncmake ..\nmake\n./unit_tests",
            "title": "Building and Flashing"
        },
        {
            "location": "/developer-guide/building-flashing/#building-and-flashing-the-firmware",
            "text": "These documents are designed to help developers get up and running with developing new features and understanding the internals of the firmware.  Development is currently supported only on Ubuntu Linux 16.04.",
            "title": "Building and Flashing the firmware"
        },
        {
            "location": "/developer-guide/building-flashing/#building-firmware-from-source",
            "text": "To build the firmware, you will need the latest version of the ARM embedded toolchain.  sudo apt install -y lib32ncurses5\nwget https://launchpad.net/gcc-arm-embedded/5.0/5-2016-q3-update/+download/gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2\ntar -xvf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2\nsudo mv gcc-arm-none-eabi-5_4-2016q3 /opt/. echo   \"export PATH=\\$PATH:/opt/gcc-arm-none-eabi-5_4-2016q3/bin\"  >> ~/.bashrc\nrm -rf gcc-arm-none-eabi-5_4-2016q3-20160926-linux.tar.bz2  Then, simply clone the repository, pull down the submodules, and build:  git clone https://github.com/rosflight/firmware cd  firmware\ngit submodule update --init --recursive\nmake",
            "title": "Building firmware from source"
        },
        {
            "location": "/developer-guide/building-flashing/#flashing-newly-built-firmware-f4",
            "text": "",
            "title": "Flashing newly built firmware (F4)"
        },
        {
            "location": "/developer-guide/building-flashing/#configure-your-machine-to-recognize-the-flight-controller",
            "text": "Be sure your user is in the  dialout  and  plugdev  group so you have access to the serial ports sudo usermod -a -G plugdev <username>\nsudo usermod -a -G dialout <username> \nDisable the modem-manager (sometimes linux thinks the device is a modem) sudo systemctl stop ModemManager.service   Tip  dfu-util auto-detects F4-based boards.  Try  dfu-util  -ls to make sure your board is in bootloader mode",
            "title": "Configure your machine to recognize the flight controller"
        },
        {
            "location": "/developer-guide/building-flashing/#f4",
            "text": "Install the dfu-util utility  sudo apt install dfu-util  Then put the board in bootloader mode (short the boot pins while cycling power) and type  make flash",
            "title": "F4"
        },
        {
            "location": "/developer-guide/building-flashing/#f1",
            "text": "Install the stm32flash utility  git clone git://git.code.sf.net/p/stm32flash/code stm32flash-code cd  stm32flash-code\nsudo make install cd  ..\nrm -rf stm32flash-code",
            "title": "F1"
        },
        {
            "location": "/developer-guide/building-flashing/#building-and-running-unit-tests",
            "text": "Contributions will need to pass our continuous integration unit tests before merging.  To test your contributions against these tests, you'll first need to install Eigen and gtest  sudo apt install libgtest-dev libeigen3-dev cmake cd  /usr/src/gtest\nsudo cmake CMakeLists.txt\nsudo make\nsudo cp *.a /usr/lib  Then you'll need to build and run the tests themselves  cd  <firmware_directory>/test\nmkdir build cd  build\ncmake ..\nmake\n./unit_tests",
            "title": "Building and running unit tests"
        },
        {
            "location": "/developer-guide/debugging/",
            "text": "Using an In-Circuit Debugger with a Naze32 (and variants)\n\u00b6\n\n\nDebugging a naze32 is easiest with an ST-Link V2.  You can find these on Amazon and other websites. The following guide will get you up and running with QtCreator and the in-circuit debugger.\n\n\n\n\nWarning\n\n\nWe have had reports of problems with cheap clones of ST-Links not connecting.\n\n\n\n\n\n\nWarning\n\n\nIt appears that perhaps debugging only works with Ubuntu 16.04 because of some issues with gdb-py and the \"textinfo\" tool in 14.04.\n\n\n\n\nAdd User to Dailout Group\n\u00b6\n\n\nFirst, make sure you are in the \ndialout\n group:\n\n\nsudo adduser \n$USER\n dialout\n\n\n\n\nLog out and back in for changes to take effect.\n\n\nInstall QtCreator\n\u00b6\n\n\nFor some reason, the QtCreator bundled with 16.04 is unstable.  4.2.0 messes up ROS workspaces, so the most recent stable build for use with ROS and debugging is 4.1.0.  Download it from \nhere\n.\n\n\nThis downloads a \n.7z\n file, which requires \np7zip\n to extract.  After downloading extract and install qtcreator:\n\n\nsudo apt-get install p7zip-full\n\ncd\n ~/Downloads\nmkdir qtcreator\nmv qtcreator.7z qtcreator/.\n\ncd\n qtcreator\np7zip -d qtcreator.7z\n\ncd\n ..\nsudo mv qtcreator /opt/.\nsudo ln -s /opt/qtcreator/bin/qtcreator /usr/bin/.\n\n\n\n\nIf you want the icon to appear in your unity menu, create the following file as /usr/share/applications/qtcreator.desktop\n\n\n[Desktop Entry]\n\n\nExec\n=\nbash -i -c qtcreator %F\n\n\nIcon\n=\nqtcreator\n\n\nType\n=\nApplication\n\n\nTerminal\n=\nfalse\n\n\nName\n=\nQt Creator\n\n\nGenericName\n=\nIntegrated Development Environment\n\n\nMimeType\n=\ntext/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.nokia.qt.qmakeprofile;application/vnd.nokia.xml.qt.resource;\n\n\nCategories\n=\nQt;Development;IDE;\n\n\nInitialPreference\n=\n9\n\n\n\n\n\nInstall openocd\n\u00b6\n\n\nOpen OCD (On-Chip-Debugger) is the software that will control the debugger.  We are going to install the version that is configured to work as a plugin for the eclipse IDE.  To get this version, go to the \nreleases\n page of the OpenOCD github page and download the latest \n.tgz\n file\n\n\ncd\n ~/Downloads\ntar -xvf gnuarmeclipse-openocd-debian32-0.10.0-201610281609-dev.tgz \n(\nor whatever\n)\n\nsudo mv openocd /opt/.\n\n\n\n\nThen, for convenience, I normally create a script to run openocd for me.  Here is my \nstart_openocd_f1\n script\n\n\n#!/bin/bash\n\n\ncd\n /opt/openocd/0.10.0-201701241841/bin\n./openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg\n\n\n\n\nHere is my \nstart_openocd_f4\n script\n\n\n#!/bin/bash\n\n\ncd\n /opt/openocd/0.10.0-5-20171110-1117/bin\n./openocd -f interface/stlink-v2.cfg -f target/stm32f4x.cfg\n\n\n\n\nI move these the \nusr/local/bin\n directory so I can call it from anywhere:\n\n\nchmod +x start_openocd_f1\nchmod +x start_openocd_f4\nmv start_openocd_f1 usr/local/bin\nmv start_openocd_f4 usr/local/bin\n\n\n\n\nInstall ARM compiler and 32-bit Dependencies\n\u00b6\n\n\nFollow the guide in \nBuilding and Flashing\n to install the compiler.\n\n\nQtCreator also needs 32-bit python bindings to run GDB\n\n\nsudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libpython2.7:i386\n\n\n\n\nConfigure QtCreator for ARM Development\n\u00b6\n\n\nOpen up the new QtCreator you just installed (make sure it's the new one, and not the version you get from \napt-get\n)\n\n\nTurn on the \"Bare Metal Plugin\"\n\u00b6\n\n\nHelp -> About Plugins -> Enable \"Bare Metal\"\n\n\nRestart QtCreator\n\n\nNow, we're going to configure a new \"Kit\" for ARM development (this allows you to quickly switch back and forth between ARM and normal development)\n\n\nTell QtCreator where to find the compiler (GCC)\n\u00b6\n\n\n\n\nTools -> Options -> Build & Run -> Compilers -> Add -> GCC -> C++.\n\n\nName the new compiler \"G++ ARM\" (or something)\n\n\nPoint the compiler path to where you just installed your fresh GCC.\n\n\nThe path for G++ \n/opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-g++\n\n\n\n\nDo the same for GCC (if you are going to be doing any C-only code)\n\n\n\n\nTools -> Options -> Build & Run -> Compilers -> Add -> GCC -> C.\n\n\nName the compiler (I named my compiler \"GCC ARM)\n\n\nThe path for GCC is \n/opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc\n\n\n\n\n\n\nAdd the Debugger (GDB)\n\u00b6\n\n\n\n\nTools -> Options -> Build & Run -> Debuggers -> Add -> GDB.\n\n\nName it something\n\n\nPoint it to the new debugger you just installed\n\n\nThe Path for \n/opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb-py\n\n\n\n\n\n\nConfigure the STLink-V2 with OpenOCD\n\u00b6\n\n\nGo to the Bare Metal Plugin\n\n\n\n\nTools -> Options -> Devices -> Bare Metal -> Add -> OpenOCD\n\n\nLeave all options at default values and click Apply\n\n\n\nTools -> Options -> Devices -> Devices -> Add -> Bare Metal Device -> Start Wizard\n\n\nName:\n ST-Link V2\n\n\nGDB Server Provider:\n OpenOCD\n\n\n\n\n\nBuild the new Development Kit\n\u00b6\n\n\n\n\nTools -> Options -> Build & Run -> Kits -> Add\n\n\nName: ARM\n\n\nDevice Type: Bare Metal Device\n\n\nDevice: ST-Link V2\n\n\nCompiler: GCC ARM/G++ ARM\n\n\nDebugger: ARM GDB\n\n\nQt Version: None\n\n\n\n\n\n\nTest the Debugger\n\u00b6\n\n\nTurn on Debugger\n\u00b6\n\n\nConnect the Debugger to your flight controller.  Here is the pinout for the Flip32 and flip32+\n\n\n\nPlug in the debugger and start openocd (you'll need sudo privileges)\n\n\nsudo start_openocd_f1\n\n\nBuild the Correct Example Code\n\u00b6\n\n\n\n\nImport Existing Project\n\n\nOpen the root of the firmware\n\n\nDo \nnot\n add .creator files to the Git repository\n\n\n\n\nConfigure the Build Environment\n\u00b6\n\n\n\n\nGo to the Projects Tab on the left hand side\n\n\nSwitch to the ARM Kit we just created\n\n\nBuild Settings:\n\n\nChange Build Directory to the firmware root\n\n\nBuild Steps: \nmake DEBUG=GDB\n\n\n\n\n\n\n\n\nRun Settings:\n\n\nChange Run Configuration to hardware debugger\n\n\nChoose the \n.elf\n file in the \nboards/naze/build\n directory (you'll need to build first) \n.../firmware/boards/naze/build/rosflight.elf\n\n\n\n\n\n\n\n\n\n\nYou're done!  Just select the Debug tab and debug your project!",
            "title": "Using a Debugger"
        },
        {
            "location": "/developer-guide/debugging/#using-an-in-circuit-debugger-with-a-naze32-and-variants",
            "text": "Debugging a naze32 is easiest with an ST-Link V2.  You can find these on Amazon and other websites. The following guide will get you up and running with QtCreator and the in-circuit debugger.   Warning  We have had reports of problems with cheap clones of ST-Links not connecting.    Warning  It appears that perhaps debugging only works with Ubuntu 16.04 because of some issues with gdb-py and the \"textinfo\" tool in 14.04.",
            "title": "Using an In-Circuit Debugger with a Naze32 (and variants)"
        },
        {
            "location": "/developer-guide/debugging/#add-user-to-dailout-group",
            "text": "First, make sure you are in the  dialout  group:  sudo adduser  $USER  dialout  Log out and back in for changes to take effect.",
            "title": "Add User to Dailout Group"
        },
        {
            "location": "/developer-guide/debugging/#install-qtcreator",
            "text": "For some reason, the QtCreator bundled with 16.04 is unstable.  4.2.0 messes up ROS workspaces, so the most recent stable build for use with ROS and debugging is 4.1.0.  Download it from  here .  This downloads a  .7z  file, which requires  p7zip  to extract.  After downloading extract and install qtcreator:  sudo apt-get install p7zip-full cd  ~/Downloads\nmkdir qtcreator\nmv qtcreator.7z qtcreator/. cd  qtcreator\np7zip -d qtcreator.7z cd  ..\nsudo mv qtcreator /opt/.\nsudo ln -s /opt/qtcreator/bin/qtcreator /usr/bin/.  If you want the icon to appear in your unity menu, create the following file as /usr/share/applications/qtcreator.desktop  [Desktop Entry]  Exec = bash -i -c qtcreator %F  Icon = qtcreator  Type = Application  Terminal = false  Name = Qt Creator  GenericName = Integrated Development Environment  MimeType = text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.nokia.qt.qmakeprofile;application/vnd.nokia.xml.qt.resource;  Categories = Qt;Development;IDE;  InitialPreference = 9",
            "title": "Install QtCreator"
        },
        {
            "location": "/developer-guide/debugging/#install-openocd",
            "text": "Open OCD (On-Chip-Debugger) is the software that will control the debugger.  We are going to install the version that is configured to work as a plugin for the eclipse IDE.  To get this version, go to the  releases  page of the OpenOCD github page and download the latest  .tgz  file  cd  ~/Downloads\ntar -xvf gnuarmeclipse-openocd-debian32-0.10.0-201610281609-dev.tgz  ( or whatever ) \nsudo mv openocd /opt/.  Then, for convenience, I normally create a script to run openocd for me.  Here is my  start_openocd_f1  script  #!/bin/bash  cd  /opt/openocd/0.10.0-201701241841/bin\n./openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg  Here is my  start_openocd_f4  script  #!/bin/bash  cd  /opt/openocd/0.10.0-5-20171110-1117/bin\n./openocd -f interface/stlink-v2.cfg -f target/stm32f4x.cfg  I move these the  usr/local/bin  directory so I can call it from anywhere:  chmod +x start_openocd_f1\nchmod +x start_openocd_f4\nmv start_openocd_f1 usr/local/bin\nmv start_openocd_f4 usr/local/bin",
            "title": "Install openocd"
        },
        {
            "location": "/developer-guide/debugging/#install-arm-compiler-and-32-bit-dependencies",
            "text": "Follow the guide in  Building and Flashing  to install the compiler.  QtCreator also needs 32-bit python bindings to run GDB  sudo dpkg --add-architecture i386\nsudo apt-get update\nsudo apt-get install libpython2.7:i386",
            "title": "Install ARM compiler and 32-bit Dependencies"
        },
        {
            "location": "/developer-guide/debugging/#configure-qtcreator-for-arm-development",
            "text": "Open up the new QtCreator you just installed (make sure it's the new one, and not the version you get from  apt-get )",
            "title": "Configure QtCreator for ARM Development"
        },
        {
            "location": "/developer-guide/debugging/#turn-on-the-bare-metal-plugin",
            "text": "Help -> About Plugins -> Enable \"Bare Metal\"  Restart QtCreator  Now, we're going to configure a new \"Kit\" for ARM development (this allows you to quickly switch back and forth between ARM and normal development)",
            "title": "Turn on the \"Bare Metal Plugin\""
        },
        {
            "location": "/developer-guide/debugging/#tell-qtcreator-where-to-find-the-compiler-gcc",
            "text": "Tools -> Options -> Build & Run -> Compilers -> Add -> GCC -> C++.  Name the new compiler \"G++ ARM\" (or something)  Point the compiler path to where you just installed your fresh GCC.  The path for G++  /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-g++   Do the same for GCC (if you are going to be doing any C-only code)   Tools -> Options -> Build & Run -> Compilers -> Add -> GCC -> C.  Name the compiler (I named my compiler \"GCC ARM)  The path for GCC is  /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc",
            "title": "Tell QtCreator where to find the compiler (GCC)"
        },
        {
            "location": "/developer-guide/debugging/#add-the-debugger-gdb",
            "text": "Tools -> Options -> Build & Run -> Debuggers -> Add -> GDB.  Name it something  Point it to the new debugger you just installed  The Path for  /opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb-py",
            "title": "Add the Debugger (GDB)"
        },
        {
            "location": "/developer-guide/debugging/#configure-the-stlink-v2-with-openocd",
            "text": "Go to the Bare Metal Plugin   Tools -> Options -> Devices -> Bare Metal -> Add -> OpenOCD  Leave all options at default values and click Apply  Tools -> Options -> Devices -> Devices -> Add -> Bare Metal Device -> Start Wizard  Name:  ST-Link V2  GDB Server Provider:  OpenOCD",
            "title": "Configure the STLink-V2 with OpenOCD"
        },
        {
            "location": "/developer-guide/debugging/#build-the-new-development-kit",
            "text": "Tools -> Options -> Build & Run -> Kits -> Add  Name: ARM  Device Type: Bare Metal Device  Device: ST-Link V2  Compiler: GCC ARM/G++ ARM  Debugger: ARM GDB  Qt Version: None",
            "title": "Build the new Development Kit"
        },
        {
            "location": "/developer-guide/debugging/#test-the-debugger",
            "text": "",
            "title": "Test the Debugger"
        },
        {
            "location": "/developer-guide/debugging/#turn-on-debugger",
            "text": "Connect the Debugger to your flight controller.  Here is the pinout for the Flip32 and flip32+  Plug in the debugger and start openocd (you'll need sudo privileges)  sudo start_openocd_f1",
            "title": "Turn on Debugger"
        },
        {
            "location": "/developer-guide/debugging/#build-the-correct-example-code",
            "text": "Import Existing Project  Open the root of the firmware  Do  not  add .creator files to the Git repository",
            "title": "Build the Correct Example Code"
        },
        {
            "location": "/developer-guide/debugging/#configure-the-build-environment",
            "text": "Go to the Projects Tab on the left hand side  Switch to the ARM Kit we just created  Build Settings:  Change Build Directory to the firmware root  Build Steps:  make DEBUG=GDB     Run Settings:  Change Run Configuration to hardware debugger  Choose the  .elf  file in the  boards/naze/build  directory (you'll need to build first)  .../firmware/boards/naze/build/rosflight.elf      You're done!  Just select the Debug tab and debug your project!",
            "title": "Configure the Build Environment"
        },
        {
            "location": "/developer-guide/writing-documentation/",
            "text": "Writing Documentation\n\u00b6\n\n\nAll documentation for the entire ROSflight stack (both firmware and ROS code) belongs in this \"ReadTheDocs\" webpage.  Here I will explain quickly how to build the documentation on your own local computer so you can view changes as you write and contribute to the documentation.\n\n\nInstall mkdocs and latex support\n\u00b6\n\n\nThis is easy:\n\n\nsudo -H pip install mkdocs, pygments, pymarkdown pymdown-extensions mkdocs-material\nsudo -H pip install https://github.com/mitya57/python-markdown-math/archive/master.zip\n\n\n\n\n(You don't have use to the global pip if you have python environments working, but for beginners, this is the simplest way to do it)\n\n\nRun the mkdocs server\n\u00b6\n\n\nJust type\n\n\nmkdocs serve\n\n\n\n\nin the root directory of the firmware repository.  It should report to you something like\n\n\n[\nI \n170728\n \n07\n:49:47 server:271\n]\n Serving on http://127.0.0.1:8000\n\n[\nI \n170728\n \n07\n:49:47 handlers:58\n]\n Start watching changes\n\n\n\n\nThis means that mkdocs is hosting a webpage for you on \nhttp://127.0.0.1:8000\n.  Navigate to that page in your web browser.\n\n\nNow, as you make changes to the documentation, you should be able to see it on your browser.  Just hit reload from time to time to see your changes.\n\n\nAdding pages\n\u00b6\n\n\nTo add a new page to the documentation, just check out the mkdocs.yaml file in the root of the firmware directory, you should be able to figure it out from there.\n\n\nAdding latex\n\u00b6\n\n\nThe syntax for adding latex math inline is \n\\( x \\)\n which renders as \nx \nx \n.  For adding a block, it's\n\n\n$$\n E \n=\n mc^\n2\n \n$$\n\n\n\nwhich renders as\n\n E = mc^2",
            "title": "Writing Documentation"
        },
        {
            "location": "/developer-guide/writing-documentation/#writing-documentation",
            "text": "All documentation for the entire ROSflight stack (both firmware and ROS code) belongs in this \"ReadTheDocs\" webpage.  Here I will explain quickly how to build the documentation on your own local computer so you can view changes as you write and contribute to the documentation.",
            "title": "Writing Documentation"
        },
        {
            "location": "/developer-guide/writing-documentation/#install-mkdocs-and-latex-support",
            "text": "This is easy:  sudo -H pip install mkdocs, pygments, pymarkdown pymdown-extensions mkdocs-material\nsudo -H pip install https://github.com/mitya57/python-markdown-math/archive/master.zip  (You don't have use to the global pip if you have python environments working, but for beginners, this is the simplest way to do it)",
            "title": "Install mkdocs and latex support"
        },
        {
            "location": "/developer-guide/writing-documentation/#run-the-mkdocs-server",
            "text": "Just type  mkdocs serve  in the root directory of the firmware repository.  It should report to you something like  [ I  170728   07 :49:47 server:271 ]  Serving on http://127.0.0.1:8000 [ I  170728   07 :49:47 handlers:58 ]  Start watching changes  This means that mkdocs is hosting a webpage for you on  http://127.0.0.1:8000 .  Navigate to that page in your web browser.  Now, as you make changes to the documentation, you should be able to see it on your browser.  Just hit reload from time to time to see your changes.",
            "title": "Run the mkdocs server"
        },
        {
            "location": "/developer-guide/writing-documentation/#adding-pages",
            "text": "To add a new page to the documentation, just check out the mkdocs.yaml file in the root of the firmware directory, you should be able to figure it out from there.",
            "title": "Adding pages"
        },
        {
            "location": "/developer-guide/writing-documentation/#adding-latex",
            "text": "The syntax for adding latex math inline is  \\( x \\)  which renders as  x  x  .  For adding a block, it's  $$  E  =  mc^ 2   $$  \nwhich renders as  E = mc^2",
            "title": "Adding latex"
        }
    ]
}